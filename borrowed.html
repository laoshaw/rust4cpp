<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>borrowed pointers - Rust for CPP Programmers</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">1.</strong> hello world</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">2.</strong> control flow</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">3.</strong> primitive types</a></li><li class="chapter-item expanded "><a href="unique.html"><strong aria-hidden="true">4.</strong> unique pointers</a></li><li class="chapter-item expanded "><a href="borrowed.html" class="active"><strong aria-hidden="true">5.</strong> borrowed pointers</a></li><li class="chapter-item expanded "><a href="rc-raw.html"><strong aria-hidden="true">6.</strong> rc and raw pointers</a></li><li class="chapter-item expanded "><a href="data-types.html"><strong aria-hidden="true">7.</strong> data types</a></li><li class="chapter-item expanded "><a href="destructuring.html"><strong aria-hidden="true">8.</strong> destructuring 1</a></li><li class="chapter-item expanded "><a href="destructuring-2.html"><strong aria-hidden="true">9.</strong> destructuring 2</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">10.</strong> arrays and vecs</a></li><li class="chapter-item expanded "><a href="graphs/index.html"><strong aria-hidden="true">11.</strong> graphs and arena_allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/src/mod.rs.html"><strong aria-hidden="true">11.1.</strong> mod</a></li><li class="chapter-item expanded "><a href="graphs/src/rc_graph.rs.html"><strong aria-hidden="true">11.2.</strong> rc_graph</a></li><li class="chapter-item expanded "><a href="graphs/src/ref_graph_generic_mod.rs.html"><strong aria-hidden="true">11.3.</strong> ref_graph_generic_mod</a></li><li class="chapter-item expanded "><a href="graphs/src/ref_graph.rs.html"><strong aria-hidden="true">11.4.</strong> ref_graph</a></li></ol></li><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">12.</strong> closures and first-class functions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for CPP Programmers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="borrowed-pointers"><a class="header" href="#borrowed-pointers">Borrowed pointers</a></h1>
<p>In the last post I introduced unique pointers. This time I will talk about
another kind of pointer which is much more common in most Rust programs:
borrowed pointers (aka borrowed references, or just references).</p>
<p>If we want to have a reference to an existing value (as opposed to creating a
new value on the heap and pointing to it, as with unique pointers), we must use
<code>&amp;</code>, a borrowed reference. These are probably the most common kind of pointer in
Rust, and if you want something to fill in for a C++ pointer or reference (e.g.,
for passing a parameter to a function by reference), this is probably it.</p>
<p>We use the <code>&amp;</code> operator to create a borrowed reference and to indicate reference
types, and <code>*</code> to dereference them. The same rules about automatic dereferencing
apply as for unique pointers. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = &amp;3;   // type: &amp;i32
    let y = *x;   // 3, type: i32
    bar(x, *x);
    bar(&amp;y, y);
}

fn bar(z: &amp;i32, i: i32) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>&amp;</code> operator does not allocate memory (we can only create a borrowed
reference to an existing value) and if a borrowed reference goes out of scope,
no memory gets deleted.</p>
<p>Borrowed references are not unique - you can have multiple borrowed references
pointing to the same value. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 5;                // type: i32
    let y = &amp;x;               // type: &amp;i32
    let z = y;                // type: &amp;i32
    let w = y;                // type: &amp;i32
    println!(&quot;These should all be 5: {} {} {}&quot;, *w, *y, *z);
}
<span class="boring">}
</span></code></pre></pre>
<p>Like values, borrowed references are immutable by default. You can also use
<code>&amp;mut</code> to take a mutable reference, or to denote mutable reference types.
Mutable borrowed references are unique (you can only take a single mutable
reference to a value, and you can only have a mutable reference if there are no
immutable references). You can use a mutable reference where an immutable one is
wanted, but not vice versa. Putting all that together in an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;i32) { ... }
fn bar_mut(x: &amp;mut i32) { ... }  // &amp;mut i32 is a reference to an i32 which
                                 // can be mutated

fn foo() {
    let x = 5;
    //let xr = &amp;mut x;     // Error - can't make a mutable reference to an
                           // immutable variable
    let xr = &amp;x;           // Ok (creates an immutable ref)
    bar(xr);
    //bar_mut(xr);         // Error - expects a mutable ref

    let mut x = 5;
    let xr = &amp;x;           // Ok (creates an immutable ref)
    //*xr = 4;             // Error - mutating immutable ref
    //let xr = &amp;mut x;     // Error - there is already an immutable ref, so we
                           // can't make a mutable one

    let mut x = 5;
    let xr = &amp;mut x;       // Ok (creates a mutable ref)
    *xr = 4;               // Ok
    //let xr2 = &amp;x;        // Error - there is already a mutable ref, so we
                           // can't make an immutable one
    //let xr2 = &amp;mut x;    // Error - can only have one mutable ref at a time
    bar(xr);               // Ok
    bar_mut(xr);           // Ok
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the reference may be mutable (or not) independently of the mutableness
of the variable holding the reference. This is similar to C++ where pointers can
be const (or not) independently of the data they point to. This is in contrast
to unique pointers, where the mutableness of the pointer is linked to the
mutableness of the data. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;
    let mut y = 6;
    let xr = &amp;mut x;
    //xr = &amp;mut y;        // Error xr is immutable

    let mut x = 5;
    let mut y = 6;
    let mut xr = &amp;mut x;
    xr = &amp;mut y;          // Ok

    let x = 5;
    let y = 6;
    let mut xr = &amp;x;
    xr = &amp;y;              // Ok - xr is mut, even though the referenced data is not
}
<span class="boring">}
</span></code></pre></pre>
<p>If a mutable value is borrowed, it becomes immutable for the duration of the
borrow. Once the borrowed pointer goes out of scope, the value can be mutated
again. This is in contrast to unique pointers, which once moved can never be
used again. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;            // type: i32
    {
        let y = &amp;x;           // type: &amp;i32
        //x = 4;              // Error - x has been borrowed
        println!(&quot;{}&quot;, x);    // Ok - x can be read
    }
    x = 4;                    // OK - y no longer exists
}
<span class="boring">}
</span></code></pre></pre>
<p>The same thing happens if we take a mutable reference to a value - the value
still cannot be modified. In general in Rust, data can only ever be modified via
one variable or pointer. Furthermore, since we have a mutable reference, we
can't take an immutable reference. That limits how we can use the underlying
value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;            // type: i32
    {
        let y = &amp;mut x;       // type: &amp;mut i32
        //x = 4;              // Error - x has been borrowed
        //println!(&quot;{}&quot;, x);  // Error - requires borrowing x
    }
    x = 4;                    // OK - y no longer exists
}
<span class="boring">}
</span></code></pre></pre>
<p>Unlike C++, Rust won't automatically reference a value for you. So if a function
takes a parameter by reference, the caller must reference the actual parameter.
However, pointer types will automatically be converted to a reference:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;i32) { ... }

fn bar(x: i32, y: Box&lt;i32&gt;) {
    foo(&amp;x);
    // foo(x);   // Error - expected &amp;i32, found i32
    foo(y);      // Ok
    foo(&amp;*y);    // Also ok, and more explicit, but not good style
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="mut-vs-const"><a class="header" href="#mut-vs-const"><code>mut</code> vs <code>const</code></a></h2>
<p>At this stage it is probably worth comparing <code>mut</code> in Rust to <code>const</code> in C++.
Superficially they are opposites. Values are immutable by default in Rust and
can be made mutable by using <code>mut</code>. Values are mutable by default in C++, but
can be made constant by using <code>const</code>. The subtler and more important difference
is that C++ const-ness applies only to the current use of a value, whereas
Rust's immutability applies to all uses of a value. So in C++ if I have a
<code>const</code> variable, someone else could have a non-const reference to it and it
could change without me knowing. In Rust if you have an immutable variable, you
are guaranteed it won't change.</p>
<p>As we mentioned above, all mutable variables are unique. So if you have a
mutable value, you know it is not going to change unless you change it.
Furthermore, you can change it freely since you know that no one else is relying
on it not changing.</p>
<h2 id="borrowing-and-lifetimes"><a class="header" href="#borrowing-and-lifetimes">Borrowing and lifetimes</a></h2>
<p>One of the primary safety goals of Rust is to avoid dangling pointers (where a
pointer outlives the memory it points to). In Rust, it is impossible to have a
dangling borrowed reference. It is only legal to create a borrowed reference to
memory which will be alive longer than the reference (well, at least as long as
the reference). In other words, the lifetime of the reference must be shorter
than the lifetime of the referenced value.</p>
<p>That has been accomplished in all the examples in this post. Scopes introduced
by <code>{}</code> or functions are bounds on lifetimes - when a variable goes out of scope
its lifetime ends. If we try to take a reference to a shorter lifetime, such as
in a narrower scope, the compiler will give us an error. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 5;
    let mut xr = &amp;x;        // Ok - x and xr have the same lifetime
    {
        let y = 6;
        xr = &amp;y             // Error - xr will outlive y
    }                       // y is released here
    println!(&quot;{?:}&quot;, xr);   // xr is used here so it outlives y. Try to comment out this line.
}                           // x and xr are released here
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, xr and y don't have the same lifetime because y starts
later than xr, but it's the end of lifetimes which is more interesting, since you
can't reference a variable before it exists in any case - something else which
Rust enforces and which makes it safer than C++.</p>
<h2 id="explicit-lifetimes"><a class="header" href="#explicit-lifetimes">Explicit lifetimes</a></h2>
<p>After playing with borrowed pointers for a while, you'll probably come across
borrowed pointers with an explicit lifetime. These have the syntax <code>&amp;'a T</code> (<a href="https://en.wikipedia.org/wiki/Cf.">cf.</a>
<code>&amp;T</code>). They're kind of a big topic since I need to cover lifetime-polymorphism
at the same time so I'll leave it for another post (there are a few more less
common pointer types to cover first though). For now, I just want to say that
<code>&amp;T</code> is a shorthand for <code>&amp;'a T</code> where <code>a</code> is the current scope, that is the
scope in which the type is declared.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unique.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="rc-raw.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unique.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="rc-raw.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
