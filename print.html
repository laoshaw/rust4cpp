<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for CPP Programmers</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">1.</strong> hello world</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">2.</strong> control flow</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">3.</strong> primitive types</a></li><li class="chapter-item expanded "><a href="unique.html"><strong aria-hidden="true">4.</strong> unique pointers</a></li><li class="chapter-item expanded "><a href="borrowed.html"><strong aria-hidden="true">5.</strong> borrowed pointers</a></li><li class="chapter-item expanded "><a href="rc-raw.html"><strong aria-hidden="true">6.</strong> rc and raw pointers</a></li><li class="chapter-item expanded "><a href="data-types.html"><strong aria-hidden="true">7.</strong> data types</a></li><li class="chapter-item expanded "><a href="destructuring.html"><strong aria-hidden="true">8.</strong> destructuring 1</a></li><li class="chapter-item expanded "><a href="destructuring-2.html"><strong aria-hidden="true">9.</strong> destructuring 2</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">10.</strong> arrays and vecs</a></li><li class="chapter-item expanded "><a href="graphs/index.html"><strong aria-hidden="true">11.</strong> graphs and arena_allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/src/mod.rs.html"><strong aria-hidden="true">11.1.</strong> mod</a></li><li class="chapter-item expanded "><a href="graphs/src/rc_graph.rs.html"><strong aria-hidden="true">11.2.</strong> rc_graph</a></li><li class="chapter-item expanded "><a href="graphs/src/ref_graph_generic_mod.rs.html"><strong aria-hidden="true">11.3.</strong> ref_graph_generic_mod</a></li><li class="chapter-item expanded "><a href="graphs/src/ref_graph.rs.html"><strong aria-hidden="true">11.4.</strong> ref_graph</a></li></ol></li><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">12.</strong> closures and first-class functions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for CPP Programmers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-for-systems-programmers"><a class="header" href="#rust-for-systems-programmers">Rust For Systems Programmers</a></h1>
<p>A Rust tutorial for experienced C and C++ programmers.</p>
<p>https://github.com/nrc/r4cppp</p>
<p>Jump to <a href="index.html#contents">contents</a>.
Jump to <a href="index.html#contributing">contributing</a>.</p>
<p>This tutorial is intended for programmers who already know how pointers and
references work and are used to systems programming concepts such as integer
widths and memory management. We intend to cover, primarily, the differences
between Rust and C++ to get you writing Rust programs quickly without lots of
fluff you probably already know.</p>
<p>Hopefully, Rust is a pretty intuitive language for C++ programmers. Most of the
syntax is pretty similar. The big difference (in my experience) is that the
sometimes vague concepts of good systems programming are strictly enforced by
the compiler. This can be infuriating at first - there are things you want to
do, but the compiler won't let you (at least in safe code), and sometimes these
things <em>are</em> safe, but you can't convince the compiler of that. However, you'll
quickly develop a good intuition for what is allowed. Communicating your own
notions of memory safety to the compiler requires some new and sometimes
complicated type annotations. But if you have a strong idea of lifetimes for
your objects and experience with generic programming, they shouldn't be too
tough to learn.</p>
<p>This tutorial started as a <a href="http://featherweightmusings.blogspot.co.nz/search/label/rust-for-c">series of blog posts</a>.
Partly as an aid for me (@nrc) learning Rust (there is no better way to
check that you have learnt something than to try and explain it to somebody
else) and partly because I found the existing resources for learning Rust
unsatisfactory - they spent too much time on the basics that I already knew and
used higher level intuitions to describe concepts that could better be explained
to me using lower level intuitions. Since then, the documentation for Rust has
got <em>much</em> better, but I still think that existing C++ programmers are an
audience who are a natural target for Rust, but are not particularly well
catered for.</p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ol>
<li><a href="hello-world.html">Introduction - Hello world!</a></li>
<li><a href="control-flow.html">Control flow</a></li>
<li><a href="primitives.html">Primitive types and operators</a></li>
<li><a href="unique.html">Unique pointers</a></li>
<li><a href="borrowed.html">Borrowed pointers</a></li>
<li><a href="rc-raw.html">Rc and raw pointers</a></li>
<li><a href="data-types.html">Data types</a></li>
<li><a href="destructuring.html">Destructuring pt 1</a></li>
<li><a href="destructuring-2.html">Destructuring pt 2</a></li>
<li><a href="arrays.html">Arrays and vecs</a></li>
<li><a href="graphs/README.html">Graphs and arena allocation</a></li>
<li><a href="closures.html">Closures and first-class functions</a></li>
</ol>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<ul>
<li><a href="http://doc.rust-lang.org/book/">The Rust book/guide</a> - the best place for
learning Rust in general and probably the best place to go for a second opinion
on stuff here or for stuff not covered.</li>
<li><a href="http://doc.rust-lang.org/std/index.html">Rust API documentation</a> - detailed
documentation for the Rust libraries.</li>
<li><a href="https://doc.rust-lang.org/reference/">The Rust reference manual</a> - a little
out of date in places, but thorough; good for looking up details.</li>
<li><a href="http://users.rust-lang.org/">Discuss forum</a> - general forum for discussion or
questions about using and learning Rust.</li>
<li><a href="https://stackoverflow.com/questions/tagged/rust">StackOverflow Rust questions</a> - answers
to many beginner and advanced questions about Rust, but be careful though - Rust
has changed <em>a lot</em> over the years and some of the answers might be very out of date.</li>
<li><a href="https://www.youtube.com/watch?v=IPmRDS0OSxM">A Firehose of Rust</a> - a recorded talk
introducing C++ programmers to how lifetimes, mutable aliasing, and move semantics work
in Rust</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Yes please!</p>
<p>If you spot a typo or mistake, please submit a PR, don't be shy! Please feel
free to file <a href="https://github.com/nrc/r4cppp/issues/new">an issue</a> for
larger changes or for new chapters you'd like to see. I'd also be happy to see
re-organisation of existing work or expanded examples, if you feel the tutorial
could be improved in those ways.</p>
<p>If you'd like to contribute a paragraph, section, or chapter please do! If you
want ideas for things to cover, see the <a href="https://github.com/nrc/r4cppp/issues">list of issues</a>,
in particular those tagged <a href="https://github.com/nrc/r4cppp/labels/new%20material">new material</a>.
If you're not sure of something, please get in touch by pinging me here
(@nrc) or on irc (nrc, on #rust or #rust-internals).</p>
<h3 id="style"><a class="header" href="#style">Style</a></h3>
<p>Obviously, the intended audience is C++ programmers. The tutorial should
concentrate on things that will be new to experienced C++ programmers, rather
than a general audience (although, I don't assume the audience is familiar with
the most recent versions of C++). I'd like to avoid too much basic material and
definitely avoid too much overlap with other resources, in particular the Rust
guide/book.</p>
<p>Work on edge case use cases (e.g., using a different build system from Cargo, or
writing syntax extensions, using unstable APIs) is definitely welcome, as is
in-depth work on topics already covered at a high level.</p>
<p>I'd like to avoid recipe-style examples for converting C++ code to Rust code,
but small examples of this kind are OK.</p>
<p>Use of different formats (e.g., question and answer/FAQs, or larger worked
examples) are welcome.</p>
<p>I don't plan on adding exercises or suggestions for mini-projects, but if you're
interested in that, let me know.</p>
<p>I'm aiming for a fairly academic tone, but not too dry. All writing should be in
English (British English, not American English; although I would be very happy
to have localisations/translations into any language, including American
English) and be valid GitHub markdown. For advice on writing style, grammar,
punctuation, etc. see the Oxford Style Manual
or <a href="http://www.economist.com/styleguide/introduction">The Economist Style Guide</a>.
Please limit width to 80 columns. I am a fan of the Oxford comma.</p>
<p>Don't feel like work has to be perfect to be submitted, I'm happy to edit and
I'm sure other people will be in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction---hello-world"><a class="header" href="#introduction---hello-world">Introduction - hello world!</a></h1>
<p>If you are using C or C++, it is probably because you have to - either you need
low-level access to the system, or need every last drop of performance, or both.
Rust aims to offer the same level of abstraction around memory, the same
performance, but be safer and make you more productive.</p>
<p>Concretely, there are many languages out there that you might prefer to use to
C++: Java, Scala, Haskell, Python, and so forth, but you can't because either
the level of abstraction is too high (you don't get direct access to memory,
you are forced to use garbage collection, etc.), or there are performance issues
(either performance is unpredictable or it's simply not fast enough). Rust does
not force you to use garbage collection, and as in C++, you get raw pointers to
memory to play with. Rust subscribes to the 'pay for what you use' philosophy of
C++. If you don't use a feature, then you don't pay any performance overhead for
its existence. Furthermore, all language features in Rust have a predictable (and
usually small) cost.</p>
<p>Whilst these constraints make Rust a (rare) viable alternative to C++, Rust also
has benefits: it is memory safe - Rust's type system ensures that you don't get
the kind of memory errors which are common in C++ - accessing un-initialised
memory, and dangling pointers - all are impossible in Rust. Furthermore,
whenever other constraints allow, Rust strives to prevent other safety issues
too - for example, all array indexing is bounds checked (of course, if you want
to avoid the cost, you can (at the expense of safety) - Rust allows you to do
this in unsafe blocks, along with many other unsafe things. Crucially, Rust
ensures that unsafety in unsafe blocks stays in unsafe blocks and can't affect
the rest of your program). Finally, Rust takes many concepts from modern
programming languages and introduces them to the systems language space.
Hopefully, that makes programming in Rust more productive, efficient, and
enjoyable.</p>
<p>In the rest of this section we'll download and install Rust, create a minimal
Cargo project, and implement Hello World.</p>
<h2 id="getting-rust"><a class="header" href="#getting-rust">Getting Rust</a></h2>
<p>You can get Rust from <a href="http://www.rust-lang.org/install.html">http://www.rust-lang.org/install.html</a>.
The downloads from there include the Rust compiler, standard libraries, and
Cargo, which is a package manager and build tool for Rust.</p>
<p>Rust is available on three channels: stable, beta, and nightly. Rust works on a
rapid-release, schedule with new releases every six weeks. On the release date,
nightly becomes beta and beta becomes stable.</p>
<p>Nightly is updated every night and is ideal for users who want to experiment with
cutting edge features and ensure that their libraries will work with future Rust.</p>
<p>Stable is the right choice for most users. Rust's stability guarantees only
apply to the stable channel.</p>
<p>Beta is designed to mostly be used in users' CI to check that their code will
continue to work as expected.</p>
<p>So, you probably want the stable channel. If you're on Linux or OS X, the
easiest way to get it is to run</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>On Windows, a similarly easy way would be to run</p>
<pre><code>choco install rust
</code></pre>
<p>For other ways to install, see <a href="http://www.rust-lang.org/install.html">http://www.rust-lang.org/install.html</a>.</p>
<p>You can find the source at <a href="https://github.com/rust-lang/rust">github.com/rust-lang/rust</a>.
To build the compiler, run <code>./configure &amp;&amp; make rustc</code>. See
<a href="https://github.com/rust-lang/rust#building-from-source">building-from-source</a>
for more detailed instructions.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h2>
<p>The easiest and most common way to build Rust programs is to use Cargo. To start
a project called <code>hello</code> using Cargo, run <code>cargo new --bin hello</code>. This will
create a new directory called <code>hello</code> inside which is a <code>Cargo.toml</code> file and
a <code>src</code> directory with a file called <code>main.rs</code>.</p>
<p><code>Cargo.toml</code> defines dependencies and other metadata about our project. We'll
come back to it in detail later.</p>
<p>All our source code will go in the <code>src</code> directory. <code>main.rs</code> already contains
a Hello World program. It looks like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>To build the program, run <code>cargo build</code>. To build and run it, <code>cargo run</code>. If
you do the latter, you should be greeted in the console. Success!</p>
<p>Cargo will have made a <code>target</code> directory and put the executable in there.</p>
<p>If you want to use the compiler directly you can run <code>rustc src/hello.rs</code> which
will create an executable called <code>hello</code>. See <code>rustc --help</code> for lots of
options.</p>
<p>OK, back to the code. A few interesting points - we use <code>fn</code> to define a
function or method. <code>main()</code> is the default entry point for our programs (we'll
leave program args for later). There are no separate declarations or header
files as with C++. <code>println!</code> is Rust's equivalent of printf. The <code>!</code> means that
it is a macro. A subset of the standard library is available without needing to
be explicitly imported/included (the prelude). The <code>println!</code> macro is included
as part of that subset.</p>
<p>Lets change our example a little bit:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let world = &quot;world&quot;;
    println!(&quot;Hello {}!&quot;, world);
}
</code></pre></pre>
<p><code>let</code> is used to introduce a variable, world is the variable name and it is a
string (technically the type is <code>&amp;'static str</code>, but more on that later). We
don't need to specify the type, it will be inferred for us.</p>
<p>Using <code>{}</code> in the <code>println!</code> statement is like using <code>%s</code> in printf. In fact, it
is a bit more general than that because Rust will try to convert the variable to
a string if it is not one already<sup><a href="hello-world.html#1">1</a></sup> (like <code>operator&lt;&lt;()</code> in C++).
You can easily play around with this sort of thing - try multiple strings and
using numbers (integer and float literals will work).</p>
<p>If you like, you can explicitly give the type of <code>world</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let world: &amp;'static str = &quot;world&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>In C++ we write <code>T x</code> to declare a variable <code>x</code> with type <code>T</code>. In Rust we write
<code>x: T</code>, whether in <code>let</code> statements or function signatures, etc. Mostly we omit
explicit types in <code>let</code> statements, but they are required for function
arguments. Lets add another function to see it work:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(_x: &amp;'static str) -&gt; &amp;'static str {
    &quot;world&quot;
}

fn main() {
    println!(&quot;Hello {}!&quot;, foo(&quot;bar&quot;));
}
</code></pre></pre>
<p>The function <code>foo</code> has a single argument <code>_x</code> which is a string literal (we pass
it &quot;bar&quot; from <code>main</code>)<sup><a href="hello-world.html#2">2</a></sup>.</p>
<p>The return type for a function is given after <code>-&gt;</code>. If the function doesn't
return anything (a void function in C++), we don't need to give a return type at
all (as in <code>main</code>). If you want to be super-explicit, you can write <code>-&gt; ()</code>,
<code>()</code> is the void type in Rust.</p>
<p>You don't need the <code>return</code> keyword in Rust, if the last expression in a
function body (or any other block, we'll see more of this later) is not finished
with a semicolon, then it is the return value. So <code>foo</code> will return
&quot;world&quot;. The <code>return</code> keyword still exists so we can do early returns. You can
replace <code>&quot;world&quot;</code> with <code>return &quot;world&quot;;</code> and it will have the same effect.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>I would like to motivate some of the language features above. Local type
inference is convenient and useful without sacrificing safety or performance
(it's even in modern versions of C++ now). A minor convenience is that language
items are consistently denoted by keyword (<code>fn</code>, <code>let</code>, etc.), this makes
scanning by eye or by tools easier, in general the syntax of Rust is simpler and
more consistent than C++. The <code>println!</code> macro is safer than printf - the number
of arguments is statically checked against the number of 'holes' in the string
and the arguments are type checked. This means you can't make the printf
mistakes of printing memory as if it had a different type or addressing memory
further down the stack by mistake. These are fairly minor things, but I hope
they illustrate the philosophy behind the design of Rust.</p>
<h5 id="1"><a class="header" href="#1">1</a></h5>
<p>This is a programmer specified conversion which uses the <code>Display</code> trait, which
works a bit like <code>toString</code> in Java. You can also use <code>{:?}</code> which gives a
compiler generated representation which is sometimes useful for debugging. As
with printf, there are many other options.</p>
<h5 id="2"><a class="header" href="#2">2</a></h5>
<p>We don't actually use that argument in <code>foo</code>. Usually,
Rust will warn us about this. By prefixing the argument name with <code>_</code> we avoid
these warnings. In fact, we don't need to name the argument at all, we could
just use <code>_</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h1>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<p>The <code>if</code> statement is pretty much the same in Rust as C++. One difference is
that the braces are mandatory, but parentheses around the expression being tested
are not. Another is that <code>if</code> is an expression, so you can use it the same way
as the ternary <code>?:</code> operator in C++ (remember from the previous section that if the last
expression in a block is not terminated by a semi-colon, then it becomes the
value of the block). There is no ternary <code>?:</code> in Rust. So, the following two
functions do the same thing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: i32) -&gt; &amp;'static str {
    let result: &amp;'static str;
    if x &lt; 10 {
        result = &quot;less than 10&quot;;
    } else {
        result = &quot;10 or more&quot;;
    }
    return result;
}

fn bar(x: i32) -&gt; &amp;'static str {
    if x &lt; 10 {
        &quot;less than 10&quot;
    } else {
        &quot;10 or more&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>(Why not <code>mut result</code>? The code in <code>foo</code> makes <code>result</code> immutable, it's just initialized in two possible places. Rust can see that by the time of <code>return result</code>, it is guaranteed to have been initialized.)</p>
<p>The first is a fairly literal translation of what you might write in C++. The
second is better Rust style.</p>
<p>You can also write <code>let x = if ...</code>, etc.</p>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Rust has while loops, again just like C++:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 10;
    while x &gt; 0 {
        println!(&quot;Current value: {}&quot;, x);
        x -= 1;
    }
}
</code></pre></pre>
<p>There is no <code>do...while</code> loop in Rust, but there is the <code>loop</code> statement which
just loops forever:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!(&quot;Just looping&quot;);
    }
}
</code></pre></pre>
<p>Rust has <code>break</code> and <code>continue</code> just like C++.</p>
<h2 id="for-loops"><a class="header" href="#for-loops">For loops</a></h2>
<p>Rust also has <code>for</code> loops, but these are a bit different. Lets say you have a
vector of integers and you want to print them all (we'll cover vectors/arrays,
iterators, and generics in more detail in the future. For now, know that a
<code>Vec&lt;T&gt;</code> is a sequence of <code>T</code>s and <code>iter()</code> returns an iterator from anything
you might reasonably want to iterate over). A simple <code>for</code> loop would look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_all(all: Vec&lt;i32&gt;) {
    for a in all.iter() {
        println!(&quot;{}&quot;, a);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>TODO also &amp;all/all instead of all.iter()</p>
<p>If we want to index over the indices of <code>all</code> (a bit more like a standard C++
for loop over an array), you could do</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_all(all: Vec&lt;i32&gt;) {
    for i in 0..all.len() {
        println!(&quot;{}: {}&quot;, i, all[i]);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Hopefully, it is obvious what the <code>len</code> function does. TODO range notation</p>
<p>A more Rust-like equivalent of the preceding example would be to use an
enumerating iterator:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_all(all: Vec&lt;i32&gt;) {
    for (i, a) in all.iter().enumerate() {
        println!(&quot;{}: {}&quot;, i, a);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>enumerate()</code> chains from the iterator <code>iter()</code> and yields the current
count and the element during iteration.</p>
<p><em>The following example incorporates more advanced topics covered in the section
on <a href="borrowed.html">Borrowed Pointers</a>.</em> Let's say you have a vector of integers
and want to call the function, passing the vector by reference and have the
vector modified in place. Here the <code>for</code> loop uses a mutable iterator which
gives mutable refererences - the <code>*</code> dereferencing should be familiar to C++
programmers:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn double_all(all: &amp;mut Vec&lt;i32&gt;) {
    for a in all.iter_mut() {
        *a += *a;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="switchmatch"><a class="header" href="#switchmatch">Switch/Match</a></h2>
<p>Rust has a match expression which is similar to a C++ switch statement, but much
more powerful. This simple version should look pretty familiar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_some(x: i32) {
    match x {
        0 =&gt; println!(&quot;x is zero&quot;),
        1 =&gt; println!(&quot;x is one&quot;),
        10 =&gt; println!(&quot;x is ten&quot;),
        y =&gt; println!(&quot;x is something else {}&quot;, y),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are some syntactic differences - we use <code>=&gt;</code> to go from the matched value
to the expression to execute, and the match arms are separated by <code>,</code> (that last
<code>,</code> is optional). There are also some semantic differences which are not so
obvious: the matched patterns must be exhaustive, that is all possible values of
the matched expression (<code>x</code> in the above example) must be covered. Try removing
the <code>y =&gt; ...</code> line and see what happens; that is because we only have matches
for 0, 1, and 10, but there are obviously lots of other integers which don't get
matched. In that last arm, <code>y</code> is bound to the value being matched (<code>x</code> in this
case). We could also write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_some(x: i32) {
    match x {
        x =&gt; println!(&quot;x is something else {}&quot;, x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>x</code> in the match arm introduces a new variable which hides the argument
<code>x</code>, just like declaring a variable in an inner scope.</p>
<p>If we don't want to name the variable, we can use <code>_</code> for an unnamed variable,
which is like having a wildcard match. If we don't want to do anything, we can
provide an empty branch:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_some(x: i32) {
    match x {
        0 =&gt; println!(&quot;x is zero&quot;),
        1 =&gt; println!(&quot;x is one&quot;),
        10 =&gt; println!(&quot;x is ten&quot;),
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Another semantic difference is that there is no fall through from one arm to the
next so it works like <code>if...else if...else</code>.</p>
<p>We'll see in later posts that match is extremely powerful. For now I want to
introduce just a couple more features - the 'or' operator for values and <code>if</code>
clauses on arms. Hopefully an example is self-explanatory:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_some_more(x: i32) {
    match x {
        0 | 1 | 10 =&gt; println!(&quot;x is one of zero, one, or ten&quot;),
        y if y &lt; 20 =&gt; println!(&quot;x is less than 20, but not zero, one, or ten&quot;),
        y if y == 200 =&gt; println!(&quot;x is 200 (but this is not very stylish)&quot;),
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Just like <code>if</code> expressions, <code>match</code> statements are actually expressions so we
could re-write the last example as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_some_more(x: i32) {
    let msg = match x {
        0 | 1 | 10 =&gt; &quot;one of zero, one, or ten&quot;,
        y if y &lt; 20 =&gt; &quot;less than 20, but not zero, one, or ten&quot;,
        y if y == 200 =&gt; &quot;200 (but this is not very stylish)&quot;,
        _ =&gt; &quot;something else&quot;
    };

    println!(&quot;x is {}&quot;, msg);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note the semi-colon after the closing brace, that is because the <code>let</code> statement
is a statement and must take the form <code>let msg = ...;</code>. We fill the rhs with a
match expression (which doesn't usually need a semi-colon), but the <code>let</code>
statement does. This catches me out all the time.</p>
<p>Motivation: Rust match statements avoid the common bugs with C++ switch
statements - you can't forget a <code>break</code> and unintentionally fall through; if you
add a case to an enum (more later on) the compiler will make sure it is covered
by your <code>match</code> statement.</p>
<h2 id="method-call"><a class="header" href="#method-call">Method call</a></h2>
<p>Finally, just a quick note that methods exist in Rust, similarly to C++. They
are always called via the <code>.</code> operator (no <code>-&gt;</code>, more on this in another post).
We saw a few examples above (<code>len</code>, <code>iter</code>). We'll go into more detail in the
future about how they are defined and called. Most assumptions you might make
from C++ or Java are probably correct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types-and-operators"><a class="header" href="#primitive-types-and-operators">Primitive types and operators</a></h1>
<p>Rust has pretty much the same arithmetic and logical operators as C++. <code>bool</code> is
the same in both languages (as are the <code>true</code> and <code>false</code> literals). Rust has
similar concepts of integers, unsigned integers, and floats. However the syntax
is a bit different. Rust uses <code>isize</code> to mean an integer and <code>usize</code> to mean an
unsigned integer. These types are pointer sized. E.g., on a 32 bit system,
<code>usize</code> means a 32 bit unsigned integer. Rust also has explicitly sized types
which are <code>u</code> or <code>i</code> followed by 8, 16, 32, 64, or 128. So, for example, <code>u8</code> is
an 8 bit unsigned integer and <code>i32</code> is a 32 bit signed integer. For floats, Rust
has <code>f32</code> and <code>f64</code>.</p>
<p>Numeric literals can take suffixes to indicate their type. If no suffix is given, Rust tries to infer the
type. If it can't infer, it uses <code>i32</code> or <code>f64</code> (if there is a decimal point).
Examples:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: bool = true;
    let x = 34;   // type i32
    // let x = 2147483648; // error: literal out of range for `i32`
    let x = 34isize;
    let x = 34usize;
    let x = 34u8;
    let x = 34i64;
    let x = 34f32;
}
</code></pre></pre>
<p>As a side note, Rust lets you redefine variables so the above code is legal -
each <code>let</code> statement creates a new variable <code>x</code> and hides the previous one. This
is more useful than you might expect due to variables being immutable by
default.</p>
<p>Numeric literals can be given as binary, octal, and hexadecimal, as well as
decimal. Use the <code>0b</code>, <code>0o</code>, and <code>0x</code> prefixes, respectively. You can use an
underscore anywhere in a numeric literal and it will be ignored. E.g,</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 12;
    let x = 0b1100;
    let x = 0o14;
    let x = 0xe;
    let y = 0b_1100_0011_1011_0001;
}
</code></pre></pre>
<p>Rust has chars and strings, but since they are Unicode, they are a bit different
from C++. I'm going to postpone talking about them until after I've introduced
pointers, references, and vectors (arrays).</p>
<p>Rust does not implicitly coerce numeric types. In general, Rust has much less
implicit coercion and subtyping than C++. Rust uses the <code>as</code> keyword for
explicit coercions and casting. Any numeric value can be cast to another numeric
type. <code>as</code> cannot be used to convert from numeric types to boolean types, but
the reverse can be done. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 34usize as isize;   // cast usize to isize
    let x = 10 as f32;      // isize to float
    let x = 10.45f64 as i8; // float to i8 (loses precision)
    let x = 4u8 as u64;     // gains precision
    let x = 400u16 as u8;   // 144, loses precision (and thus changes the value)
    println!(&quot;`400u16 as u8` gives {}&quot;, x);
    let x = -3i8 as u8;     // 253, signed to unsigned (changes sign)
    println!(&quot;`-3i8 as u8` gives {}&quot;, x);
    //let x = 45 as bool;  // FAILS! (use 45 != 0 instead)
    let x = true as usize;  // cast bool to usize (gives a 1)
}}
</code></pre></pre>
<p>Rust has the following operators:</p>
<table><thead><tr><th>Type</th><th>Operators</th></tr></thead><tbody>
<tr><td>Numeric</td><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td></tr>
<tr><td>Bitwise</td><td><code>\|</code>, <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></td></tr>
<tr><td>Comparison</td><td><code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></td></tr>
<tr><td>Short-circuit logical</td><td><code>\|\|</code>, <code>&amp;&amp;</code></td></tr>
</tbody></table>
<p>All of these behave as in C++, however, Rust is a bit stricter about the types
the operators can be applied to - the bitwise operators can only be applied to
integers and the logical operators can only be applied to booleans. Rust has the
<code>-</code> unary operator which negates a number. The <code>!</code> operator negates a boolean
and inverts every bit on an integer type (equivalent to <code>~</code> in C++ in the latter
case). Rust has compound assignment operators as in C++, e.g., <code>+=</code>, but does
not have increment or decrement operators (e.g., <code>++</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unique-pointers"><a class="header" href="#unique-pointers">Unique pointers</a></h1>
<p>Rust is a systems language and therefore must give you raw access to memory. It
does this (as in C++) via pointers. Pointers are one area where Rust and C++ are
very different, both in syntax and semantics. Rust enforces memory safety by
type checking pointers. That is one of its major advantages over other
languages. Although the type system is a bit complex, you get memory safety and
bare-metal performance in return.</p>
<p>I had intended to cover all of Rust's pointers in one post, but I think the
subject is too large. So this post will cover just one kind - unique pointers -
and other kinds will be covered in follow up posts.</p>
<p>First, an example without pointers:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 75;

    // ... do something with `x` ...
}
<span class="boring">}
</span></code></pre></pre>
<p>When we reach the end of <code>foo</code>, <code>x</code> goes out of scope (in Rust as in C++). That
means the variable can no longer be accessed and the memory for the variable can
be reused.</p>
<p>In Rust, for every type <code>T</code> we can write <code>Box&lt;T&gt;</code> for an owning (aka unique)
pointer to <code>T</code>. We use <code>Box::new(...)</code> to allocate space on the heap and
initialise that space with the supplied value. This is similar to <code>new</code> in C++.
For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = Box::new(75);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>x</code> is a pointer to a location on the heap which contains the value <code>75</code>.
<code>x</code> has type <code>Box&lt;i32&gt;</code>; we could have written <code>let x: Box&lt;i32&gt; = Box::new(75);</code>. This is similar to writing <code>int* x = new int(75);</code> in C++.
Unlike in C++, Rust will tidy up the memory for us, so there is no need to call
<code>free</code> or <code>delete</code><sup><a href="unique.html#1">1</a></sup>. Unique pointers behave similarly to
values - they are deleted when the variable goes out of scope. In our example,
at the end of the function <code>foo</code>, <code>x</code> can no longer be accessed and the memory
pointed at by <code>x</code> can be reused.</p>
<p>Owning pointers are dereferenced using the <code>*</code> as in C++. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = Box::new(75);
    println!(&quot;`x` points to {}&quot;, *x);
}
<span class="boring">}
</span></code></pre></pre>
<p>As with primitive types in Rust, owning pointers and the data they point to are
immutable by default. Unlike in C++, you can't have a mutable (unique) pointer to
immutable data or vice versa. Mutability of the data follows from the pointer.
E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = Box::new(75);
    let y = Box::new(42);
    // x = y;         // Not allowed, x is immutable.
    // *x = 43;       // Not allowed, *x is immutable.
    let mut x = Box::new(75);
    x = y;            // OK, x is mutable.
    *x = 43;          // OK, *x is mutable.
}
<span class="boring">}
</span></code></pre></pre>
<p>Owning pointers can be returned from a function and continue to live on. If they
are returned, then their memory will not be freed, i.e., there are no dangling
pointers in Rust. The memory will not leak. However, it will eventually go out of
scope and then it will be freed. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Box&lt;i32&gt; {
    let x = Box::new(75);
    x
}

fn bar() {
    let y = foo();
    // ... use y ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, memory is initialised in <code>foo</code>, and returned to <code>bar</code>. <code>x</code> is returned
from <code>foo</code> and stored in <code>y</code>, so it is not deleted. At the end of <code>bar</code>, <code>y</code>
goes out of scope and so the memory is reclaimed.</p>
<p>Owning pointers are unique (also called linear) because there can be only one
(owning) pointer to any piece of memory at any time. This is accomplished by
move semantics. When one pointer points at a value, any previous pointer can no
longer be accessed. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = Box::new(75);
    let y = x;
    // x can no longer be accessed
    // let z = *x;   // Error.
}
<span class="boring">}
</span></code></pre></pre>
<p>Likewise, if an owning pointer is passed to another function or stored in a
field, it can no longer be accessed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(y: Box&lt;isize&gt;) {
}

fn foo() {
    let x = Box::new(75);
    bar(x);
    // x can no longer be accessed
    // let z = *x;   // Error.
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust's unique pointers are similar to C++ <code>std::unique_ptr</code>s. In Rust, as in
C++, there can be only one unique pointer to a value and that value is deleted
when the pointer goes out of scope. Rust does most of its checking statically
rather than at runtime. So, in C++ accessing a unique pointer whose value has
moved will result in a runtime error (since it will be null). In Rust this
produces a compile time error and you cannot go wrong at runtime.</p>
<p>We'll see later that it is possible to create other pointer types which point at
a unique pointer's value in Rust. This is similar to C++. However, in C++ this
allows you to cause errors at runtime by holding a pointer to freed memory. That
is not possible in Rust (we'll see how when we cover Rust's other pointer
types).</p>
<p>As shown above, owning pointers must be dereferenced to use their values.
However, method calls automatically dereference, so there is no need for a <code>-&gt;</code>
operator or to use <code>*</code> for method calls. In this way, Rust pointers are a bit
similar to both pointers and references in C++. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: Box&lt;Foo&gt;, y: Box&lt;Box&lt;Box&lt;Box&lt;Foo&gt;&gt;&gt;&gt;) {
    x.foo();
    y.foo();
}
<span class="boring">}
</span></code></pre></pre>
<p>Assuming that the type <code>Foo</code> has a method <code>foo()</code>, both these expressions are OK.</p>
<p>Calling <code>Box::new()</code> with an existing value does not take a reference to that
value, it copies that value. So,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 3;
    let mut y = Box::new(x);
    *y = 45;
    println!(&quot;x is still {}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>In general, Rust has move rather than copy semantics (as seen above with unique
pointers). Primitive types have copy semantics, so in the above example the
value <code>3</code> is copied, but for more complex values it would be moved. We'll cover
this in more detail later.</p>
<p>Sometimes when programming, however, we need more than one reference to a value.
For that, Rust has borrowed pointers. I'll cover those in the next post.</p>
<h5 id="1-1"><a class="header" href="#1-1">1</a></h5>
<p>The <code>std::unique_ptr&lt;T&gt;</code>, introduced in C++11, is similar in some aspects
to Rust's <code>Box&lt;T&gt;</code> but there are also significant differences.</p>
<p>Similarities:</p>
<ul>
<li>The memory pointed to by a <code>std::unique_ptr&lt;T&gt;</code> in C++11 and a <code>Box&lt;T&gt;</code> in Rust
is automatically released once the <code>std::unique_ptr&lt;T&gt;</code> goes out of the scope.</li>
<li>Both C++11's <code>std::unique_ptr&lt;T&gt;</code> and Rust's <code>Box&lt;T&gt;</code> only exhibit move semantics.</li>
</ul>
<p>Differences:</p>
<ol>
<li>C++11 allows for a <code>std::unique_ptr&lt;T&gt;</code> to be constructed from an existing pointer,
thereby allowing multiple unique pointers to the same memory. 
This behaviour is not permitted with <code>Box&lt;T&gt;</code>.</li>
<li>Dereferencing a <code>std::unique_ptr&lt;T&gt;</code> that has been moved to another variable or function,
causes undefined behavior in C++11. This would be caught at compile time in Rust.</li>
<li>Mutability or immutability does not go &quot;through&quot; <code>std::unique_ptr&lt;T&gt;</code> 
-- dereferencing a <code>const std::unique_ptr&lt;T&gt;</code> still yields a mutable 
(non-<code>const</code>) reference to the underlying data. In Rust, an immutable
<code>Box&lt;T&gt;</code> does not allow mutation of the data it points to.</li>
</ol>
<p><code>let x = Box::new(75)</code> in Rust may be interpreted as <code>const auto x = std::unique_ptr&lt;const int&gt;{new int{75}};</code> in C++11 and <code>const auto x = std::make_unique&lt;const int&gt;(75);</code> in C++14.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowed-pointers"><a class="header" href="#borrowed-pointers">Borrowed pointers</a></h1>
<p>In the last post I introduced unique pointers. This time I will talk about
another kind of pointer which is much more common in most Rust programs:
borrowed pointers (aka borrowed references, or just references).</p>
<p>If we want to have a reference to an existing value (as opposed to creating a
new value on the heap and pointing to it, as with unique pointers), we must use
<code>&amp;</code>, a borrowed reference. These are probably the most common kind of pointer in
Rust, and if you want something to fill in for a C++ pointer or reference (e.g.,
for passing a parameter to a function by reference), this is probably it.</p>
<p>We use the <code>&amp;</code> operator to create a borrowed reference and to indicate reference
types, and <code>*</code> to dereference them. The same rules about automatic dereferencing
apply as for unique pointers. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = &amp;3;   // type: &amp;i32
    let y = *x;   // 3, type: i32
    bar(x, *x);
    bar(&amp;y, y);
}

fn bar(z: &amp;i32, i: i32) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>&amp;</code> operator does not allocate memory (we can only create a borrowed
reference to an existing value) and if a borrowed reference goes out of scope,
no memory gets deleted.</p>
<p>Borrowed references are not unique - you can have multiple borrowed references
pointing to the same value. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 5;                // type: i32
    let y = &amp;x;               // type: &amp;i32
    let z = y;                // type: &amp;i32
    let w = y;                // type: &amp;i32
    println!(&quot;These should all be 5: {} {} {}&quot;, *w, *y, *z);
}
<span class="boring">}
</span></code></pre></pre>
<p>Like values, borrowed references are immutable by default. You can also use
<code>&amp;mut</code> to take a mutable reference, or to denote mutable reference types.
Mutable borrowed references are unique (you can only take a single mutable
reference to a value, and you can only have a mutable reference if there are no
immutable references). You can use a mutable reference where an immutable one is
wanted, but not vice versa. Putting all that together in an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;i32) { ... }
fn bar_mut(x: &amp;mut i32) { ... }  // &amp;mut i32 is a reference to an i32 which
                                 // can be mutated

fn foo() {
    let x = 5;
    //let xr = &amp;mut x;     // Error - can't make a mutable reference to an
                           // immutable variable
    let xr = &amp;x;           // Ok (creates an immutable ref)
    bar(xr);
    //bar_mut(xr);         // Error - expects a mutable ref

    let mut x = 5;
    let xr = &amp;x;           // Ok (creates an immutable ref)
    //*xr = 4;             // Error - mutating immutable ref
    //let xr = &amp;mut x;     // Error - there is already an immutable ref, so we
                           // can't make a mutable one

    let mut x = 5;
    let xr = &amp;mut x;       // Ok (creates a mutable ref)
    *xr = 4;               // Ok
    //let xr2 = &amp;x;        // Error - there is already a mutable ref, so we
                           // can't make an immutable one
    //let xr2 = &amp;mut x;    // Error - can only have one mutable ref at a time
    bar(xr);               // Ok
    bar_mut(xr);           // Ok
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the reference may be mutable (or not) independently of the mutableness
of the variable holding the reference. This is similar to C++ where pointers can
be const (or not) independently of the data they point to. This is in contrast
to unique pointers, where the mutableness of the pointer is linked to the
mutableness of the data. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;
    let mut y = 6;
    let xr = &amp;mut x;
    //xr = &amp;mut y;        // Error xr is immutable

    let mut x = 5;
    let mut y = 6;
    let mut xr = &amp;mut x;
    xr = &amp;mut y;          // Ok

    let x = 5;
    let y = 6;
    let mut xr = &amp;x;
    xr = &amp;y;              // Ok - xr is mut, even though the referenced data is not
}
<span class="boring">}
</span></code></pre></pre>
<p>If a mutable value is borrowed, it becomes immutable for the duration of the
borrow. Once the borrowed pointer goes out of scope, the value can be mutated
again. This is in contrast to unique pointers, which once moved can never be
used again. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;            // type: i32
    {
        let y = &amp;x;           // type: &amp;i32
        //x = 4;              // Error - x has been borrowed
        println!(&quot;{}&quot;, x);    // Ok - x can be read
    }
    x = 4;                    // OK - y no longer exists
}
<span class="boring">}
</span></code></pre></pre>
<p>The same thing happens if we take a mutable reference to a value - the value
still cannot be modified. In general in Rust, data can only ever be modified via
one variable or pointer. Furthermore, since we have a mutable reference, we
can't take an immutable reference. That limits how we can use the underlying
value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;            // type: i32
    {
        let y = &amp;mut x;       // type: &amp;mut i32
        //x = 4;              // Error - x has been borrowed
        //println!(&quot;{}&quot;, x);  // Error - requires borrowing x
    }
    x = 4;                    // OK - y no longer exists
}
<span class="boring">}
</span></code></pre></pre>
<p>Unlike C++, Rust won't automatically reference a value for you. So if a function
takes a parameter by reference, the caller must reference the actual parameter.
However, pointer types will automatically be converted to a reference:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;i32) { ... }

fn bar(x: i32, y: Box&lt;i32&gt;) {
    foo(&amp;x);
    // foo(x);   // Error - expected &amp;i32, found i32
    foo(y);      // Ok
    foo(&amp;*y);    // Also ok, and more explicit, but not good style
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="mut-vs-const"><a class="header" href="#mut-vs-const"><code>mut</code> vs <code>const</code></a></h2>
<p>At this stage it is probably worth comparing <code>mut</code> in Rust to <code>const</code> in C++.
Superficially they are opposites. Values are immutable by default in Rust and
can be made mutable by using <code>mut</code>. Values are mutable by default in C++, but
can be made constant by using <code>const</code>. The subtler and more important difference
is that C++ const-ness applies only to the current use of a value, whereas
Rust's immutability applies to all uses of a value. So in C++ if I have a
<code>const</code> variable, someone else could have a non-const reference to it and it
could change without me knowing. In Rust if you have an immutable variable, you
are guaranteed it won't change.</p>
<p>As we mentioned above, all mutable variables are unique. So if you have a
mutable value, you know it is not going to change unless you change it.
Furthermore, you can change it freely since you know that no one else is relying
on it not changing.</p>
<h2 id="borrowing-and-lifetimes"><a class="header" href="#borrowing-and-lifetimes">Borrowing and lifetimes</a></h2>
<p>One of the primary safety goals of Rust is to avoid dangling pointers (where a
pointer outlives the memory it points to). In Rust, it is impossible to have a
dangling borrowed reference. It is only legal to create a borrowed reference to
memory which will be alive longer than the reference (well, at least as long as
the reference). In other words, the lifetime of the reference must be shorter
than the lifetime of the referenced value.</p>
<p>That has been accomplished in all the examples in this post. Scopes introduced
by <code>{}</code> or functions are bounds on lifetimes - when a variable goes out of scope
its lifetime ends. If we try to take a reference to a shorter lifetime, such as
in a narrower scope, the compiler will give us an error. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 5;
    let mut xr = &amp;x;        // Ok - x and xr have the same lifetime
    {
        let y = 6;
        xr = &amp;y             // Error - xr will outlive y
    }                       // y is released here
    println!(&quot;{?:}&quot;, xr);   // xr is used here so it outlives y. Try to comment out this line.
}                           // x and xr are released here
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, xr and y don't have the same lifetime because y starts
later than xr, but it's the end of lifetimes which is more interesting, since you
can't reference a variable before it exists in any case - something else which
Rust enforces and which makes it safer than C++.</p>
<h2 id="explicit-lifetimes"><a class="header" href="#explicit-lifetimes">Explicit lifetimes</a></h2>
<p>After playing with borrowed pointers for a while, you'll probably come across
borrowed pointers with an explicit lifetime. These have the syntax <code>&amp;'a T</code> (<a href="https://en.wikipedia.org/wiki/Cf.">cf.</a>
<code>&amp;T</code>). They're kind of a big topic since I need to cover lifetime-polymorphism
at the same time so I'll leave it for another post (there are a few more less
common pointer types to cover first though). For now, I just want to say that
<code>&amp;T</code> is a shorthand for <code>&amp;'a T</code> where <code>a</code> is the current scope, that is the
scope in which the type is declared.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-counted-and-raw-pointers"><a class="header" href="#reference-counted-and-raw-pointers">Reference counted and raw pointers</a></h1>
<p>TODO add discussion of custom pointers and Deref trait (maybe later, not here)</p>
<p>So far we've covered unique and borrowed pointers. Unique pointers are very
similar to the new std::unique_ptr in C++ and borrowed references are the
'default' pointer you usually reach for if you would use a pointer or reference
in C++. Rust has a few more, rarer pointers either in the libraries or built in
to the language. These are mostly similar to various kinds of smart pointers you
might be used to in C++.</p>
<p>This post took a while to write and I still don't like it. There are a lot of
loose ends here, both in my write up and in Rust itself. I hope some will get
better with later posts and some will get better as the language develops. If
you are learning Rust, you might even want to skip this stuff for now, hopefully
you won't need it. Its really here just for completeness after the posts on
other pointer types.</p>
<p>It might feel like Rust has a lot of pointer types, but it is pretty similar to
C++ once you think about the various kinds of smart pointers available in
libraries. In Rust, however, you are more likely to meet them when you first
start learning the language. Because Rust pointers have compiler support, you
are also much less likely to make errors when using them.</p>
<p>I'm not going to cover these in as much detail as unique and borrowed references
because, frankly, they are not as important. I might come back to them in more
detail later on.</p>
<h2 id="rc"><a class="header" href="#rc">Rc<T></a></h2>
<p>Reference counted pointers come as part of the rust standard library. They are
in the <code>std::rc</code> module (we'll cover modules soon-ish. The modules are the
reason for the <code>use</code> incantations in the examples). A reference counted pointer
to an object of type <code>T</code> has type <code>Rc&lt;T&gt;</code>. You create reference counted pointers
using a static method (which for now you can think of like C++'s, but we'll see
later they are a bit different) - <code>Rc::new(...)</code> which takes a value to create
the pointer to. This constructor method follows Rust's usual move/copy semantics
(like we discussed for unique pointers) - in either case, after calling Rc::new,
you will only be able to access the value via the pointer.</p>
<p>As with the other pointer types, the <code>.</code> operator does all the dereferencing you
need it to. You can use <code>*</code> to manually dereference.</p>
<p>To pass a ref-counted pointer you need to use the <code>clone</code> method. This kinda
sucks, and hopefully we'll fix that, but that is not for sure (sadly). You can
take a (borrowed) reference to the pointed at value, so hopefully you don't need
to clone too often. Rust's type system ensures that the ref-counted variable
will not be deleted before any references expire. Taking a reference has the
added advantage that it doesn't need to increment or decrement the ref count,
and so will give better performance (although, that difference is probably
marginal since Rc objects are limited to a single thread and so the ref count
operations don't have to be atomic). As in C++, you can also take a reference to
the Rc pointer.</p>
<p>An Rc example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

fn bar(x: Rc&lt;i32&gt;) { }
fn baz(x: &amp;i32) { }

fn foo() {
    let x = Rc::new(45);
    bar(x.clone());   // Increments the ref-count
    baz(&amp;*x);         // Does not increment
    println!(&quot;{}&quot;, 100 - *x);
}  // Once this scope closes, all Rc pointers are gone, so ref-count == 0
   // and the memory will be deleted.
<span class="boring">}
</span></code></pre></pre>
<p>Ref counted pointers are always immutable. If you want a mutable ref-counted
object you need to use a RefCell (or Cell) wrapped in an <code>Rc</code>.</p>
<h2 id="cell-and-refcell"><a class="header" href="#cell-and-refcell">Cell and RefCell</a></h2>
<p>Cell and RefCell are structs which allow you to 'cheat' the mutability rules.
This is kind of hard to explain without first covering Rust data structures and
how they work with mutability, so I'm going to come back to these slightly
tricky objects later. For now, you should know that if you want a mutable, ref
counted object you need a Cell or RefCell wrapped in an Rc. As a first
approximation, you probably want Cell for primitive data and RefCell for objects
with move semantics. So, for a mutable, ref-counted int you would use
<code>Rc&lt;Cell&lt;int&gt;&gt;</code>.</p>
<h2 id="t---raw-pointers"><a class="header" href="#t---raw-pointers">*T - raw pointers</a></h2>
<p>Finally, Rust has two kinds of raw pointers (aka unsafe pointers): <code>*const T</code>
for an immutable raw pointer, and <code>*mut T</code> for a mutable raw pointer. They are
created using <code>&amp;</code> or <code>&amp;mut</code> (you might need to specify a type to get a <code>*T</code>
rather than a <code>&amp;T</code> since the <code>&amp;</code> operator can create either a borrowed reference
or a raw pointer). Raw pointers are like C pointers, just a pointer to memory
with no restrictions on how they are used (you can't do pointer arithmetic
without casting, but you can do it that way if you must). Raw pointers are the
only pointer type in Rust which can be null. There is no automatic dereferencing
of raw pointers (so to call a method you have to write <code>(*x).foo()</code>) and no
automatic referencing. The most important restriction is that they can't be
dereferenced (and thus can't be used) outside of an unsafe block. In regular
Rust code you can only pass them around.</p>
<p>So, what is unsafe code? Rust has strong safety guarantees, and (rarely) they
prevent you doing something you need to do. Since Rust aims to be a systems
language, it has to be able to do anything that is possible and sometimes that
means doing things the compiler can't verify is safe. To accomplish that, Rust
has the concept of unsafe blocks, marked by the <code>unsafe</code> keyword. In unsafe code
you can do unsafe things - dereference a raw pointer, index into an array
without bounds checking, call code written in another language via the FFI, or
cast variables. Obviously, you have to be much more careful writing unsafe code
than writing regular Rust code. In fact, you should only very rarely write
unsafe code. Mostly it is used in very small chunks in libraries, rather than in
client code. In unsafe code you must do all the things you normally do in C++ to
ensure safety. Furthermore, you must manually ensure that you maintain the
invariants which the compiler would usually enforce. Unsafe blocks allow you to
manually enforce Rust's invariants, it does not allow you to break those
invariants. If you do, you can introduce bugs both in safe and unsafe code.</p>
<p>An example of using an raw pointer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let mut x = 5;
    let x_p: *mut i32 = &amp;mut x;
    println!(&quot;x+5={}&quot;, add_5(x_p));
}

fn add_5(p: *mut i32) -&gt; i32 {
    unsafe {
        if !p.is_null() { // Note that *-pointers do not auto-deref, so this is
                          // a method implemented on *i32, not i32.
            *p + 5
        } else {
            -1            // Not a recommended error handling strategy.
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And that concludes our tour of Rust's pointers. Next time we'll take a break
from pointers and look at Rust's data structures. We'll come back to borrowed
references again in a later post though.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>In this post I'll discuss Rust's data types. These are roughly equivalent to
classes, structs, and enums in C++. One difference with Rust is that data and
behaviour are much more strictly separated in Rust than C++ (or Java, or other
OO languages). Behaviour is defined by functions and those can be defined in
traits and <code>impl</code>s (implementations), but traits cannot contain data, they are
similar to Java's interfaces in that respect. I'll cover traits and impls in a
later post, this one is all about data.</p>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>A rust struct is similar to a C struct or a C++ struct without methods. Simply a
list of named fields. The syntax is best seen with an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    field1: i32,
    field2: SomeOtherStruct
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we define a struct called <code>S</code> with two fields. The fields are comma
separated; if you like, you can comma-terminate the last field too.</p>
<p>Structs introduce a type. In the example, we could use <code>S</code> as a type.
<code>SomeOtherStruct</code> is assumed to be another struct (used as a type in the
example), and (like C++) it is included by value, that is, there is no pointer
to another struct object in memory.</p>
<p>Fields in structs are accessed using the <code>.</code> operator and their name. An example
of struct use:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(s1: S, s2: &amp;S) {
    let f = s1.field1;
    if f == s2.field1 {
        println!(&quot;field1 matches!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>s1</code> is struct object passed by value and <code>s2</code> is a struct object passed by
reference. As with method calls, we use the same <code>.</code> to access fields in both, no
need for <code>-&gt;</code>.</p>
<p>Structs are initialised using struct literals. These are the name of the struct
and values for each field. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(sos: SomeOtherStruct) {
    let x = S { field1: 45, field2: sos };  // initialise x with a struct literal
    println!(&quot;x.field1 = {}&quot;, x.field1);
}
<span class="boring">}
</span></code></pre></pre>
<p>Structs cannot be recursive; that is, you can't have cycles of struct names
involving definitions and field types. This is because of the value semantics of
structs. So for example, <code>struct R { r: Option&lt;R&gt; }</code> is illegal and will cause a
compiler error (see below for more about Option). If you need such a structure
then you should use some kind of pointer; cycles with pointers are allowed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct R {
    r: Option&lt;Box&lt;R&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>If we didn't have the <code>Option</code> in the above struct, there would be no way to
instantiate the struct and Rust would signal an error.</p>
<p>Structs with no fields do not use braces in either their definition or literal
use. Definitions do need a terminating semi-colon though, presumably just to
facilitate parsing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Empty;

fn foo() {
    let e = Empty;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples are anonymous, heterogeneous sequences of data. As a type, they are
declared as a sequence of types in parentheses. Since there is no name, they are
identified by structure. For example, the type <code>(i32, i32)</code> is a pair of
integers and <code>(i32, f32, S)</code> is a triple. Tuple values are initialised in the
same way as tuple types are declared, but with values instead of types for the
components, e.g., <code>(4, 5)</code>. An example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo takes a struct and returns a tuple
fn foo(x: SomeOtherStruct) -&gt; (i32, f32, S) {
    (23, 45.82, S { field1: 54, field2: x })
}
<span class="boring">}
</span></code></pre></pre>
<p>Tuples can be used by destructuring using a <code>let</code> expression, e.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: (i32, i32)) {
    let (a, b) = x;
    println!(&quot;x was ({}, {})&quot;, a, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>We'll talk more about destructuring next time.</p>
<h2 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple structs</a></h2>
<p>Tuple structs are named tuples, or alternatively, structs with unnamed fields.
They are declared using the <code>struct</code> keyword, a list of types in parentheses,
and a semicolon. Such a declaration introduces their name as a type. Their
fields must be accessed by destructuring (like a tuple), rather than by name.
Tuple structs are not very common.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct IntPoint (i32, i32);

fn foo(x: IntPoint) {
    let IntPoint(a, b) = x;  // Note that we need the name of the tuple
                             // struct to destructure.
    println!(&quot;x was ({}, {})&quot;, a, b);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enums are types like C++ enums or unions, in that they are types which can take
multiple values. The simplest kind of enum is just like a C++ enum:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E1 {
    Var1,
    Var2,
    Var3
}

fn foo() {
    let x: E1 = Var2;
    match x {
        Var2 =&gt; println!(&quot;var2&quot;),
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, Rust enums are much more powerful than that. Each variant can contain
data. Like tuples, these are defined by a list of types. In this case they are
more like unions than enums in C++. Rust enums are tagged unions rather than untagged unions (as in C++). 
That means you can't mistake one variant of an enum for another at runtime<sup><a href="data-types.html#1">1</a></sup>. An example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Expr {
    Add(i32, i32),
    Or(bool, bool),
    Lit(i32)
}

fn foo() {
    let x = Or(true, false);   // x has type Expr
}
<span class="boring">}
</span></code></pre></pre>
<p>Many simple cases of object-oriented polymorphism are better handled in Rust
using enums.</p>
<p>To use enums we usually use a match expression. Remember that these are similar
to C++ switch statements. I'll go into more depth on these and other ways to
destructure data next time. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(e: Expr) {
    match e {
        Add(x, y) =&gt; println!(&quot;An `Add` variant: {} + {}&quot;, x, y),
        Or(..) =&gt; println!(&quot;An `Or` variant&quot;),
        _ =&gt; println!(&quot;Something else (in this case, a `Lit`)&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Each arm of the match expression matches a variant of <code>Expr</code>. All variants must
be covered. The last case (<code>_</code>) covers all remaining variants, although in the
example there is only <code>Lit</code>. Any data in a variant can be bound to a variable.
In the <code>Add</code> arm we are binding the two i32s in an <code>Add</code> to <code>x</code> and <code>y</code>. If we
don't care about the data, we can use <code>..</code> to match any data, as we do for <code>Or</code>.</p>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<p>One particularly common enum in Rust is <code>Option</code>. This has two variants - <code>Some</code>
and <code>None</code>. <code>None</code> has no data and <code>Some</code> has a single field with type <code>T</code>
(<code>Option</code> is a generic enum, which we will cover later, but hopefully the
general idea is clear from C++). Options are used to indicate a value might be
there or might not. Any place you use a null pointer in C++<sup><a href="data-types.html#2">2</a></sup>
to indicate a value which is in some way undefined, uninitialised, or false,
you should probably use an Option in Rust. Using Option is safer because you
must always check it before use; there is no way to do the equivalent of
dereferencing a null pointer. They are also more general, you can use them with
values as well as pointers. An example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

struct Node {
    parent: Option&lt;Rc&lt;Node&gt;&gt;,
    value: i32
}

fn is_root(node: Node) -&gt; bool {
    match node.parent {
        Some(_) =&gt; false,
        None =&gt; true
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the parent field could be either a <code>None</code> or a <code>Some</code> containing an
<code>Rc&lt;Node&gt;</code>. In the example, we never actually use that payload, but in real life
you usually would.</p>
<p>There are also convenience methods on Option, so you could write the body of
<code>is_root</code> as <code>node.parent.is_none()</code> or <code>!node.parent.is_some()</code>.</p>
<h2 id="inherited-mutability-and-cellrefcell"><a class="header" href="#inherited-mutability-and-cellrefcell">Inherited mutability and Cell/RefCell</a></h2>
<p>Local variables in Rust are immutable by default and can be marked mutable using
<code>mut</code>. We don't mark fields in structs or enums as mutable, their mutability is
inherited. This means that a field in a struct object is mutable or immutable
depending on whether the object itself is mutable or immutable. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct S1 {
    field1: i32,
    field2: S2
}
struct S2 {
    field: i32
}

fn main() {
    let s = S1 { field1: 45, field2: S2 { field: 23 } };
    // s is deeply immutable, the following mutations are forbidden
    // s.field1 = 46;
    // s.field2.field = 24;

    let mut s = S1 { field1: 45, field2: S2 { field: 23 } };
    // s is mutable, these are OK
    s.field1 = 46;
    s.field2.field = 24;
}
</code></pre></pre>
<p>Inherited mutability in Rust stops at references. This is similar to C++ where
you can modify a non-const object via a pointer from a const object. If you want
a reference field to be mutable, you have to use <code>&amp;mut</code> on the field type:</p>
<pre><pre class="playground"><code class="language-rust">struct S1 {
    f: i32
}
struct S2&lt;'a&gt; {
    f: &amp;'a mut S1   // mutable reference field
}
struct S3&lt;'a&gt; {
    f: &amp;'a S1       // immutable reference field
}

fn main() {
    let mut s1 = S1{f:56};
    let s2 = S2 { f: &amp;mut s1};
    s2.f.f = 45;   // legal even though s2 is immutable
    // s2.f = &amp;mut s1; // illegal - s2 is not mutable
    let s1 = S1{f:56};
    let mut s3 = S3 { f: &amp;s1};
    s3.f = &amp;s1;     // legal - s3 is mutable
    // s3.f.f = 45; // illegal - s3.f is immutable
}
</code></pre></pre>
<p>(The <code>'a</code> parameter on <code>S2</code> and <code>S3</code> is a lifetime parameter, we'll cover those soon).</p>
<p>Sometimes whilst an object is logically immutable, it has parts which need to be
internally mutable. Think of various kinds of caching or a reference count
(which would not give true logical immutability since the effect of changing the
ref count can be observed via destructors). In C++, you would use the <code>mutable</code>
keyword to allow such mutation even when the object is const. In Rust we have
the Cell and RefCell structs. These allow parts of immutable objects to be
mutated. Whilst that is useful, it means you need to be aware that when you see
an immutable object in Rust, it is possible that some parts may actually be
mutable.</p>
<p>RefCell and Cell let you get around Rust's strict rules on mutation and
aliasability. They are safe to use because they ensure that Rust's invariants
are respected dynamically, even though the compiler cannot ensure that those
invariants hold statically. Cell and RefCell are both single threaded objects.</p>
<p>Use Cell for types which have copy semantics (pretty much just primitive types).
Cell has <code>get</code> and <code>set</code> methods for changing the stored value, and a <code>new</code>
method to initialise the cell with a value. Cell is a very simple object - it
doesn't need to do anything smart since objects with copy semantics can't keep
references elsewhere (in Rust) and they can't be shared across threads, so there
is not much to go wrong.</p>
<p>Use RefCell for types which have move semantics, that means nearly everything in
Rust, struct objects are a common example. RefCell is also created using <code>new</code>
and has a <code>set</code> method. To get the value in a RefCell, you must borrow it using
the borrow methods (<code>borrow</code>, <code>borrow_mut</code>, <code>try_borrow</code>, <code>try_borrow_mut</code>)
these will give you a borrowed reference to the object in the RefCell. These
methods follow the same rules as static borrowing - you can only have one
mutable borrow, and can't borrow mutably and immutably at the same time.
However, rather than a compile error you get a runtime failure. The <code>try_</code>
variants return an Option - you get <code>Some(val)</code> if the value can be borrowed and
<code>None</code> if it can't. If a value is borrowed, calling <code>set</code> will fail too.</p>
<p>Here's an example using a ref-counted pointer to a RefCell (a common use-case):</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;

struct S {
    field: i32
}

fn foo(x: Rc&lt;RefCell&lt;S&gt;&gt;) {
    {
        let s = x.borrow();
        println!(&quot;the field, twice {} {}&quot;, s.field, x.borrow().field);
        // let s = x.borrow_mut(); // Error - we've already borrowed the contents of x
    }

    let mut s = x.borrow_mut(); // OK, the earlier borrows are out of scope
    s.field = 45;
    // println!(&quot;The field {}&quot;, x.borrow().field); // Error - can't mut and immut borrow
    println!(&quot;The field {}&quot;, s.field);
}

fn main() {
    let s = S{field:12};
    let x: Rc&lt;RefCell&lt;S&gt;&gt; = Rc::new(RefCell::new(s));
    foo(x.clone());

    println!(&quot;The field {}&quot;, x.borrow().field);
}
</code></pre></pre>
<p>If you're using Cell/RefCell, you should try to put them on the smallest object
you can. That is, prefer to put them on a few fields of a struct, rather than
the whole struct. Think of them like single threaded locks, finer grained
locking is better since you are more likely to avoid colliding on a lock.</p>
<h5 id="1-2"><a class="header" href="#1-2">1</a></h5>
<p>In C++17 there is <code>std::variant&lt;T&gt;</code> type that is closer to Rust enums than unions.</p>
<h5 id="2-1"><a class="header" href="#2-1">2</a></h5>
<p>Since C++17 <code>std::optional&lt;T&gt;</code> is the best alternative of Option in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h1>
<p>Last time we looked at Rust's data types. Once you have some data inside a structure, you
will want to get that data out. For structs, Rust has field access, just like
C++. For tuples, tuple structs, and enums you must use destructuring (there are
various convenience functions in the library, but they use destructuring
internally). Destructuring of data structures exists in C++ only since C++17, so
it most likely familiar from languages such as Python or various functional
languages.  The idea is that just as you can initialize a data structure by
filling out its fields with data from a bunch of local variables, you can fill
out a bunch of local variables with data from a data structure.  From this
simple beginning, destructuring has become one of Rust's most powerful
features. To put it another way, destructuring combines pattern matching with
assignment into local variables.</p>
<p>Destructuring is done primarily through the let and match statements. The match
statement is used when the structure being destructured can have different
variants (such as an enum). A let expression pulls the variables out into the
current scope, whereas match introduces a new scope. To compare:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(pair: (int, int)) {
    let (x, y) = pair;
    // we can now use x and y anywhere in foo

    match pair {
        (x, y) =&gt; {
            // x and y can only be used in this scope
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax for patterns (used after <code>let</code> and before <code>=&gt;</code> in the above example)
in both cases is (pretty much) the same. You can also use these patterns in
argument position in function declarations:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo((x, y): (int, int)) {
}
<span class="boring">}
</span></code></pre></pre>
<p>(Which is more useful for structs or tuple-structs than tuples).</p>
<p>Most initialisation expressions can appear in a destructuring pattern and they
can be arbitrarily complex. That can include references and primitive literals
as well as data structures. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct St {
    f1: int,
    f2: f32
}

enum En {
    Var1,
    Var2,
    Var3(int),
    Var4(int, St, int)
}

fn foo(x: &amp;En) {
    match x {
        &amp;Var1 =&gt; println!(&quot;first variant&quot;),
        &amp;Var3(5) =&gt; println!(&quot;third variant with number 5&quot;),
        &amp;Var3(x) =&gt; println!(&quot;third variant with number {} (not 5)&quot;, x),
        &amp;Var4(3, St { f1: 3, f2: x }, 45) =&gt; {
            println!(&quot;destructuring an embedded struct, found {} in f2&quot;, x)
        }
        &amp;Var4(_, ref x, _) =&gt; {
            println!(&quot;Some other Var4 with {} in f1 and {} in f2&quot;, x.f1, x.f2)
        }
        _ =&gt; println!(&quot;other (Var2)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note how we destructure through a reference by using <code>&amp;</code> in the patterns and how
we use a mix of literals (<code>5</code>, <code>3</code>, <code>St { ... }</code>), wildcards (<code>_</code>), and
variables (<code>x</code>).</p>
<p>You can use <code>_</code> wherever a variable is expected if you want to ignore a single
item in a pattern, so we could have used <code>&amp;Var3(_)</code> if we didn't care about the
integer. In the first <code>Var4</code> arm we destructure the embedded struct (a nested
pattern) and in the second <code>Var4</code> arm we bind the whole struct to a variable.
You can also use <code>..</code> to stand in for all fields of a tuple or struct. So if you
wanted to do something for each enum variant but don't care about the content of
the variants, you could write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: En) {
    match x {
        Var1 =&gt; println!(&quot;first variant&quot;),
        Var2 =&gt; println!(&quot;second variant&quot;),
        Var3(..) =&gt; println!(&quot;third variant&quot;),
        Var4(..) =&gt; println!(&quot;fourth variant&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When destructuring structs, the fields don't need to be in order and you can use
<code>..</code> to elide the remaining fields. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Big {
    field1: int,
    field2: int,
    field3: int,
    field4: int,
    field5: int,
    field6: int,
    field7: int,
    field8: int,
    field9: int,
}

fn foo(b: Big) {
    let Big { field6: x, field3: y, ..} = b;
    println!(&quot;pulled out {} and {}&quot;, x, y);
}
<span class="boring">}
</span></code></pre></pre>
<p>As a shorthand with structs you can use just the field name which creates a
local variable with that name. The let statement in the above example created
two new local variables <code>x</code> and <code>y</code>. Alternatively, you could write</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(b: Big) {
    let Big { field6, field3, .. } = b;
    println!(&quot;pulled out {} and {}&quot;, field3, field6);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we create local variables with the same names as the fields, in this case
<code>field3</code> and <code>field6</code>.</p>
<p>There are a few more tricks to Rust's destructuring. Lets say you want a
reference to a variable in a pattern. You can't use <code>&amp;</code> because that matches a
reference, rather than creates one (and thus has the effect of dereferencing the
object). For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    field: &amp;'static int
}

fn foo(x: Foo) {
    let Foo { field: &amp;y } = x;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>y</code> has type <code>int</code> and is a copy of the field in <code>x</code>.</p>
<p>To create a reference to something in a pattern, you use the <code>ref</code> keyword. For
example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(b: Big) {
    let Big { field3: ref x, ref field6, ..} = b;
    println!(&quot;pulled out {} and {}&quot;, *x, *field6);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>x</code> and <code>field6</code> both have type <code>&amp;int</code> and are references to the fields in <code>b</code>.</p>
<p>One last trick when destructuring is that if you are destructuring a complex
object, you might want to name intermediate objects as well as individual
fields. Going back to an earlier example, we had the pattern <code>&amp;Var4(3, St{ f1: 3, f2: x }, 45)</code>. In that pattern we named one field of the struct, but you
might also want to name the whole struct object. You could write <code>&amp;Var4(3, s, 45)</code> which would bind the struct object to <code>s</code>, but then you would have to use
field access for the fields, or if you wanted to only match with a specific
value in a field you would have to use a nested match. That is not fun. Rust
lets you name parts of a pattern using <code>@</code> syntax. For example <code>&amp;Var4(3, s @ St{ f1: 3, f2: x }, 45)</code> lets us name both a field (<code>x</code>, for <code>f2</code>) and the whole
struct (<code>s</code>).</p>
<p>That just about covers your options with Rust pattern matching. There are a few
features I haven't covered, such as matching vectors, but hopefully you know how
to use <code>match</code> and <code>let</code> and have seen some of the powerful things you can do.
Next time I'll cover some of the subtle interactions between match and borrowing
which tripped me up a fair bit when learning Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-pt2---match-and-borrowing"><a class="header" href="#destructuring-pt2---match-and-borrowing">Destructuring pt2 - match and borrowing</a></h1>
<p>When destructuring there are some surprises in store where borrowing is
concerned. Hopefully, nothing surprising once you understand borrowed references
really well, but worth discussing (it took me a while to figure out, that's for
sure. Longer than I realised, in fact, since I screwed up the first version of
this blog post).</p>
<p>Imagine you have some <code>&amp;Enum</code> variable <code>x</code> (where <code>Enum</code> is some enum type). You
have two choices: you can match <code>*x</code> and list all the variants (<code>Variant1 =&gt; ...</code>, etc.) or you can match <code>x</code> and list reference to variant patterns
(<code>&amp;Variant1 =&gt; ...</code>, etc.). (As a matter of style, prefer the first form where
possible since there is less syntactic noise). <code>x</code> is a borrowed reference and
there are strict rules for how a borrowed reference can be dereferenced, these
interact with match expressions in surprising ways (at least surprising to me),
especially when you are modifying an existing enum in a seemingly innocuous way
and then the compiler explodes on a match somewhere.</p>
<p>Before we get into the details of the match expression, lets recap Rust's rules
for value passing. In C++, when assigning a value into a variable or passing it
to a function there are two choices - pass-by-value and pass-by-reference. The
former is the default case and means a value is copied either using a copy
constructor or a bitwise copy. If you annotate the destination of the parameter
pass or assignment with <code>&amp;</code>, then the value is passed by reference - only a
pointer to the value is copied and when you operate on the new variable, you are
also operating on the old value.</p>
<p>Rust has the pass-by-reference option, although in Rust the source as well as
the destination must be annotated with <code>&amp;</code>. For pass-by-value in Rust, there are
two further choices - copy or move. A copy is the same as C++'s semantics
(except that there are no copy constructors in Rust). A move copies the value
but destroys the old value - Rust's type system ensures you can no longer access
the old value. As examples, <code>i32</code> has copy semantics and <code>Box&lt;i32&gt;</code> has move
semantics:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 7i32;
    let y = x;                // x is copied
    println!(&quot;x is {}&quot;, x);   // OK

    let x = Box::new(7i32);
    let y = x;                // x is moved
    //println!(&quot;x is {}&quot;, x); // error: use of moved value: `x`
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also choose to have copy semantics for user-defined types
by implementing the <code>Copy</code> trait. One straightforward way to do that is 
to add <code>#[derive(Copy)]</code> before the definition of the <code>struct</code>. Not all
user-defined types are allowed to implement the <code>Copy</code> trait. All fields of 
a type must implement <code>Copy</code> and the type must not have a destructor. 
Destructors probably need a post of their own, but for now, an object 
in Rust has a destructor if it implements the <code>Drop</code>trait. 
Just like C++, the destructor is executed just before an object is 
destroyed.</p>
<p>Now, it is important that a borrowed object is not moved, otherwise you would
have a reference to the old object which is no longer valid. This is equivalent
to holding a reference to an object which has been destroyed after going out of
scope - it is a kind of dangling pointer. If you have a pointer to an object,
there could be other references to it. So if an object has move semantics and
you have a pointer to it, it is unsafe to dereference that pointer. (If the
object has copy semantics, dereferencing creates a copy and the old object will
still exist, so other references will be fine).</p>
<p>OK, back to match expressions. As I said earlier, if you want to match some <code>x</code>
with type <code>&amp;T</code> you can dereference once in the match clause or match the
reference in every arm of the match expression. Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum1 {
    Var1,
    Var2,
    Var3
}

fn foo(x: &amp;Enum1) {
    match *x {  // Option 1: deref here.
        Enum1::Var1 =&gt; {}
        Enum1::Var2 =&gt; {}
        Enum1::Var3 =&gt; {}
    }

    match x {
        // Option 2: 'deref' in every arm.
        &amp;Enum1::Var1 =&gt; {}
        &amp;Enum1::Var2 =&gt; {}
        &amp;Enum1::Var3 =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case you can take either approach because <code>Enum1</code> has copy semantics.
Let's take a closer look at each approach: in the first approach we dereference
<code>x</code> to a temporary variable with type <code>Enum1</code> (which copies the value in <code>x</code>)
and then do a match against the three variants of <code>Enum1</code>. This is a 'one level'
match because we don't go deep into the value's type. In the second approach
there is no dereferencing. We match a value with type <code>&amp;Enum1</code> against a
reference to each variant. This match goes two levels deep - it matches the type
(always a reference) and looks inside the type to match the referred type (which
is <code>Enum1</code>).</p>
<p>Either way, we must ensure that we (that is, the compiler) respect 
Rust's invariants around moves and references - we must not move any
part of an object if it is referenced. If the value being matched has copy
semantics, that is trivial. If it has move semantics then we must make sure that
moves don't happen in any match arm. This is accomplished either by ignoring
data which would move, or making references to it (so we get by-reference
passing rather than by-move).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum2 {
    // Box has a destructor so Enum2 has move semantics.
    Var1(Box&lt;i32&gt;),
    Var2,
    Var3
}

fn foo(x: &amp;Enum2) {
    match *x {
        // We're ignoring nested data, so this is OK
        Enum2::Var1(..) =&gt; {}
        // No change to the other arms.
        Enum2::Var2 =&gt; {}
        Enum2::Var3 =&gt; {}
    }

    match x {
        // We're ignoring nested data, so this is OK
        &amp;Enum2::Var1(..) =&gt; {}
        // No change to the other arms.
        &amp;Enum2::Var2 =&gt; {}
        &amp;Enum2::Var3 =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In either approach we don't refer to any of the nested data, so none of it is
moved. In the first approach, even though <code>x</code> is referenced, we don't touch its
innards in the scope of the dereference (i.e., the match expression) so nothing
can escape. We also don't bind the whole value (i.e., bind <code>*x</code> to a variable),
so we can't move the whole object either.</p>
<p>We can take a reference to any variant in the second match, but not in the
dereferenced version. So, in the second approach replacing the second arm with <code>a @ &amp;Var2 =&gt; {}</code> is OK (<code>a</code> is a reference), but under the first approach we
couldn't write <code>a @ Var2 =&gt; {}</code> since that would mean moving <code>*x</code> into <code>a</code>. We
could write <code>ref a @ Var2 =&gt; {}</code> (in which <code>a</code> is also a reference), although
it's not a construct you see very often.</p>
<p>But what about if we want to use the data nested inside <code>Var1</code>? We can't write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match *x {
    Enum2::Var1(y) =&gt; {}
    _ =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match x {
    &amp;Enum2::Var1(y) =&gt; {}
    _ =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>because in both cases it means moving part of <code>x</code> into <code>y</code>. We can use the 'ref'
keyword to get a reference to the data in <code>Var1</code>: <code>&amp;Var1(ref y) =&gt; {}</code>. That is
OK, because now we are not dereferencing anywhere and thus not moving any part
of <code>x</code>. Instead we are creating a pointer which points into the interior of <code>x</code>.</p>
<p>Alternatively, we could destructure the Box (this match is going three levels
deep): <code>&amp;Var1(box y) =&gt; {}</code> (note <code>box</code> pattern syntax is experimental as of rustc 1.58 
and is available only in nightly version of rustc). 
This is OK because <code>i32</code> has copy semantics and <code>y</code>
is a copy of the <code>i32</code> inside the <code>Box</code> inside <code>Var1</code> (which is 'inside' a
borrowed reference). Since <code>i32</code> has copy semantics, we don't need to move any
part of <code>x</code>. We could also create a reference to the int rather than copy it:
<code>&amp;Var1(box ref y) =&gt; {}</code>. Again, this is OK, because we don't do any
dereferencing and thus don't need to move any part of <code>x</code>. If the contents of
the Box had move semantics, then we could not write <code>&amp;Var1(box y) =&gt; {}</code>, we
would be forced to use the reference version. We could also use similar
techniques with the first approach to matching, which look the same but without
the first <code>&amp;</code>. For example, <code>Var1(box ref y) =&gt; {}</code>.</p>
<p>Now lets get more complex. Lets say you want to match against a pair of
reference-to-enum values. Now we can't use the first approach at all:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;Enum2, y: &amp;Enum2) {
    // Error: x and y are being moved.
    // match (*x, *y) {
    //     (Enum2::Var2, _) =&gt; {}
    //     _ =&gt; {}
    // }

    // OK.
    match (x, y) {
        (&amp;Enum2::Var2, _) =&gt; {}
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The first approach is illegal because the value being matched is created by
dereferencing <code>x</code> and <code>y</code> and then moving them both into a new tuple object. So
in this circumstance, only the second approach works. And of course, you still
have to follow the rules above for avoiding moving parts of <code>x</code> and <code>y</code>.</p>
<p>If you do end up only being able to get a reference to some data and you need
the value itself, you have no option except to copy that data. Usually that
means using <code>clone()</code>. If the data doesn't implement clone, you're going to have
to further destructure to make a manual copy or implement clone yourself.</p>
<p>What if we don't have a reference to a value with move semantics, but the value
itself. Now moves are OK, because we know no one else has a reference to the
value (the compiler ensures that if they do, we can't use the value). For
example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn baz(x: Enum2) {
    match x {
        Enum2::Var1(y) =&gt; {}
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are still a few things to be aware of. Firstly, you can only move to one
place. In the above example we are moving part of <code>x</code> into <code>y</code> and we'll forget
about the rest. If we wrote <code>a @ Var1(y) =&gt; {}</code> we would be attempting to move
all of <code>x</code> into <code>a</code> and part of <code>x</code> into <code>y</code>. That is not allowed, an arm like
that is illegal. Making one of <code>a</code> or <code>y</code> a reference (using <code>ref a</code>, etc.) is
not an option either, then we'd have the problem described above where we move
whilst holding a reference. We can make both <code>a</code> and <code>y</code> references and then
we're OK - neither is moving, so <code>x</code> remains intact and we have pointers to the
whole and a part of it.</p>
<p>Similarly (and more common), if we have a variant with multiple pieces of nested
data, we can't take a reference to one datum and move another. For example if we
had a <code>Var4</code> declared as <code>Var4(Box&lt;int&gt;, Box&lt;int&gt;)</code> we can have a match arm
which references both (<code>Var4(ref y, ref z) =&gt; {}</code>) or a match arm which moves
both (<code>Var4(y, z) =&gt; {}</code>) but you cannot have a match arm which moves one and
references the other (<code>Var4(ref y, z) =&gt; {}</code>). This is because a partial move
still destroys the whole object, so the reference would be invalid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-vectors"><a class="header" href="#arrays-and-vectors">Arrays and Vectors</a></h1>
<p>Rust arrays are pretty different from C arrays. For starters they come in
statically and dynamically sized flavours. These are more commonly known as
fixed length arrays and slices. As we'll see, the former is kind of a bad name
since both kinds of array have fixed (as opposed to growable) length. For a
growable 'array', Rust provides the <code>Vec</code> collection.</p>
<h2 id="fixed-length-arrays"><a class="header" href="#fixed-length-arrays">Fixed length arrays</a></h2>
<p>The length of a fixed length array is known statically and features in its
type. E.g., <code>[i32; 4]</code> is the type of an array of <code>i32</code>s with length four.</p>
<p>Array literal and array access syntax is the same as C:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 4] = [1, 2, 3, 4];     // As usual, the type annotation is optional.
println!(&quot;The second element is {}&quot;, a[1]);
<span class="boring">}
</span></code></pre></pre>
<p>You'll notice that array indexing is zero-based, just like C.</p>
<p>However, unlike C/C++<sup><a href="arrays.html#1">1</a></sup>, array indexing is bounds checked. In
fact all access to arrays is bounds checked, which is another way Rust is a
safer language.</p>
<p>If you try to do <code>a[4]</code>, then you will get a runtime panic. Unfortunately, the
Rust compiler is not clever enough to give you a compile time error, even when
it is obvious (as in this example).</p>
<p>If you like to live dangerously, or just need to get every last ounce of
performance out of your program, you can still get unchecked access to arrays.
To do this, use the <code>get_unchecked</code> method on an array. Unchecked array accesses
must be inside an unsafe block. You should only need to do this in the rarest
circumstances.</p>
<p>Just like other data structures in Rust, arrays are immutable by default and
mutability is inherited. Mutation is also done via the indexing syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = [1, 2, 3, 4];
a[3] = 5;
println!(&quot;{:?}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<p>And just like other data, you can borrow an array by taking a reference to it:</p>
<pre><pre class="playground"><code class="language-rust">fn foo(a: &amp;[i32; 4]) {
    println!(&quot;First: {}; last: {}&quot;, a[0], a[3]);
}

fn main() {
    foo(&amp;[1, 2, 3, 4]);
}
</code></pre></pre>
<p>Notice that indexing still works on a borrowed array.</p>
<p>This is a good time to talk about the most interesting aspect of Rust arrays for
C++ programmers - their representation. Rust arrays are value types: they are
allocated on the stack like other values and an array object is a sequence of
values, not a pointer to those values (as in C). So from our examples above, <code>let a = [1_i32, 2, 3, 4];</code> will allocate 16 bytes on the stack and executing <code>let b = a;</code> will copy 16 bytes. If you want a C-like array, you have to explicitly
make a pointer to the array, this will give you a pointer to the first element.</p>
<p>A final point of difference between arrays in Rust and C++ is that Rust arrays
can implement traits, and thus have methods. To find the length of an array, for
example, you use <code>a.len()</code>.</p>
<h2 id="slices"><a class="header" href="#slices">Slices</a></h2>
<p>A slice in Rust is just an array whose length is not known at compile time. The
syntax of the type is just like a fixed length array, except there is no length:
e.g., <code>[i32]</code> is a slice of 32 bit integers (with no statically known length).</p>
<p>There is a catch with slices: since the compiler must know the size of all
objects in Rust, and it can't know the size of a slice, then we can never have a
value with slice type. If you try and write <code>fn foo(x: [i32])</code>, for example, the
compiler will give you an error.</p>
<p>So, you must always have pointers to slices (there are some very technical
exceptions to this rule so that you can implement your own smart pointers, but
you can safely ignore them for now). You must write <code>fn foo(x: &amp;[i32])</code> (a
borrowed reference to a slice) or <code>fn foo(x: *mut [i32])</code> (a mutable raw pointer
to a slice), etc.</p>
<p>The simplest way to create a slice is by coercion. There are far fewer implicit
coercions in Rust than there are in C++. One of them is the coercion from fixed
length arrays to slices. Since slices must be pointer values, this is
effectively a coercion between pointers. For example, we can coerce <code>&amp;[i32; 4]</code>
to <code>&amp;[i32]</code>, e.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: &amp;[i32] = &amp;[1, 2, 3, 4];
<span class="boring">}
</span></code></pre></pre>
<p>Here the right hand side is a fixed length array of length four, allocated on
the stack. We then take a reference to it (type <code>&amp;[i32; 4]</code>). That reference is
coerced to type <code>&amp;[i32]</code> and given the name <code>a</code> by the let statement.</p>
<p>Again, access is just like C (using <code>[...]</code>), and access is bounds checked. You
can also check the length yourself by using <code>len()</code>. So clearly the length of
the array is known somewhere. In fact all arrays of any kind in Rust have known
length, since this is essential for bounds checking, which is an integral part
of memory safety. The size is known dynamically (as opposed to statically in the
case of fixed length arrays), and we say that slice types are dynamically sized
types (DSTs, there are other kinds of dynamically sized types too, they'll be
covered elsewhere).</p>
<p>Since a slice is just a sequence of values, the size cannot be stored as part of
the slice. Instead it is stored as part of the pointer (remember that slices
must always exist as pointer types). A pointer to a slice (like all pointers to
DSTs) is a fat pointer - it is two words wide, rather than one, and contains the
pointer to the data plus a payload. In the case of slices, the payload is the
length of the slice.</p>
<p>So in the example above, the pointer <code>a</code> will be 128 bits wide (on a 64 bit
system). The first 64 bits will store the address of the <code>1</code> in the sequence
<code>[1, 2, 3, 4]</code>, and the second 64 bits will contain <code>4</code>. Usually, as a Rust
programmer, these fat pointers can just be treated as regular pointers. But it
is good to know about (it can affect the things you can do with casts, for
example).</p>
<h3 id="slicing-notation-and-ranges"><a class="header" href="#slicing-notation-and-ranges">Slicing notation and ranges</a></h3>
<p>A slice can be thought of as a (borrowed) view of an array. So far we have only
seen a slice of the whole array, but we can also take a slice of part of an
array. There is a special notation for this which is like the indexing
syntax, but takes a range instead of a single integer. E.g., <code>a[0..4]</code>, which
takes a slice of the first four elements of <code>a</code>. Note that the range is
exclusive at the top and inclusive at the bottom. Examples:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 4] = [1, 2, 3, 4];
let b: &amp;[i32] = &amp;a;   // Slice of the whole array.
let c = &amp;a[0..4];     // Another slice of the whole array, also has type &amp;[i32].
let c = &amp;a[1..3];     // The middle two elements, &amp;[i32].
let c = &amp;a[1..];      // The last three elements.
let c = &amp;a[..3];      // The first three elements.
let c = &amp;a[..];       // The whole array, again.
let c = &amp;b[1..3];     // We can also slice a slice.
<span class="boring">}
</span></code></pre></pre>
<p>Note that in the last example, we still need to borrow the result of slicing.
The slicing syntax produces an unborrowed slice (type: <code>[i32]</code>) which we must
then borrow (to give a <code>&amp;[i32]</code>), even if we are slicing a borrowed slice.</p>
<p>Range syntax can also be used outside of slicing syntax. <code>a..b</code> produces an
iterator which runs from <code>a</code> to <code>b-1</code>. This can be combined with other iterators
in the usual way, or can be used in <code>for</code> loops:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Print all numbers from 1 to 10.
for i in 1..11 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="vecs"><a class="header" href="#vecs">Vecs</a></h2>
<p>A vector is heap allocated and is an owning reference. Therefore (and like
<code>Box&lt;_&gt;</code>), it has move semantics. We can think of a fixed length array
analogously to a value, a slice to a borrowed reference. Similarly, a vector in
Rust is analogous to a <code>Box&lt;_&gt;</code> pointer.</p>
<p>It helps to think of <code>Vec&lt;_&gt;</code> as a kind of smart pointer, just like <code>Box&lt;_&gt;</code>,
rather than as a value itself. Similarly to a slice, the length is stored in the
'pointer', in this case the 'pointer' is the Vec value.</p>
<p>A vector of <code>i32</code>s has type <code>Vec&lt;i32&gt;</code>. There are no vector literals, but we can
get the same effect by using the <code>vec!</code> macro. We can also create an empty
vector using <code>Vec::new()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4];      // A Vec&lt;i32&gt; with length 4.
let v: Vec&lt;i32&gt; = Vec::new();  // An empty vector of i32s.
<span class="boring">}
</span></code></pre></pre>
<p>In the second case above, the type annotation is necessary so the compiler can
know what the vector is a vector of. If we were to use the vector, the type
annotation would probably not be necessary.</p>
<p>Just like arrays and slices, we can use indexing notation to get a value from
the vector (e.g., <code>v[2]</code>). Again, these are bounds checked. We can also use
slicing notation to take a slice of a vector (e.g., <code>&amp;v[1..3]</code>).</p>
<p>The extra feature of vectors is that their size can change - they can get longer
or shorter as needed. For example, <code>v.push(5)</code> would add the element <code>5</code> to the
end of the vector (this would require that <code>v</code> is mutable). Note that growing a
vector can cause reallocation, which for large vectors can mean a lot of
copying. To guard against this you can pre-allocate space in a vector using
<code>with_capacity</code>, see the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec docs</a>
for more details.</p>
<h2 id="the-index-traits"><a class="header" href="#the-index-traits">The <code>Index</code> traits</a></h2>
<p>Note for readers: there is a lot of material in this section that I haven't
covered properly yet. If you're following the tutorial, you can skip this
section, it is a somewhat advanced topic in any case.</p>
<p>The same indexing syntax used for arrays and vectors is also used for other
collections, such as <code>HashMap</code>s. And you can use it yourself for your own
collections. You opt-in to using the indexing (and slicing) syntax by
implementing the <code>Index</code> trait. This is a good example of how Rust makes
available nice syntax to user types, as well as built-ins (<code>Deref</code> for
dereferencing smart pointers, as well as <code>Add</code> and various other traits, work in
a similar way).</p>
<p>The <code>Index</code> trait looks like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Index&lt;Idx: ?Sized&gt; {
    type Output: ?Sized;

    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Idx</code> is the type used for indexing. For most uses of indexing this is <code>usize</code>.
For slicing this is one of the <code>std::ops::Range</code> types. <code>Output</code> is the type
returned by indexing, this will be different for each collection. For slicing it
will be a slice, rather than the type of a single element. <code>index</code> is a method
which does the work of getting the element(s) out of the collection. Note that
the collection is taken by reference and the method returns a reference to the
element with the same lifetime.</p>
<p>Let's look at the implementation for <code>Vec</code> to see how what an implementation
looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Index&lt;usize&gt; for Vec&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, index: usize) -&gt; &amp;T {
        &amp;(**self)[index]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As we said above, indexing is done using <code>usize</code>. For a <code>Vec&lt;T&gt;</code>, indexing will
return a single element of type <code>T</code>, thus the value of <code>Output</code>. The
implementation of <code>index</code> is a bit weird - <code>(**self)</code> gets a view of the whole
vec as a slice, then we use indexing on slices to get the element, and finally
take a reference to it.</p>
<p>If you have your own collections, you can implement <code>Index</code> in a similar way to
get indexing and slicing syntax for your collection.</p>
<h2 id="initialiser-syntax"><a class="header" href="#initialiser-syntax">Initialiser syntax</a></h2>
<p>As with all data in Rust, arrays and vectors must be properly initialised. Often
you just want an array full of zeros to start with and using the array literal
syntax is a pain. So Rust gives you a little syntactic sugar to initialise an
array full of a given value: <code>[value; len]</code>. So for example to create an array
with length 100 full of zeros, we'd use <code>[0; 100]</code>.</p>
<p>Similarly for vectors, <code>vec![42; 100]</code> would give you a vector with 100
elements, each with the value 42.</p>
<p>The initial value is not limited to integers, it can be any expression. For
array initialisers, the length must be an integer constant expression. For
<code>vec!</code>, it can be any expression with type <code>usize</code>.</p>
<h5 id="1-3"><a class="header" href="#1-3">1</a></h5>
<p>In C++11 there is <code>std::array&lt;T, N&gt;</code> that provides boundary checking when
<code>at()</code> method is used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs-and-arena-allocation"><a class="header" href="#graphs-and-arena-allocation">Graphs and arena allocation</a></h1>
<p>(Note you can run the examples in this chapter by downloading this directory and
running <code>cargo run</code>).</p>
<p>Graphs are a bit awkward to construct in Rust because of Rust's stringent
lifetime and mutability requirements. Graphs of objects are very common in OO
programming. In this tutorial I'm going to go over a few different approaches to
implementation. My preferred approach uses arena allocation and makes slightly
advanced use of explicit lifetimes. I'll finish up by discussing a few potential
Rust features which would make using such an approach easier.</p>
<p>A <a href="http://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29">graph</a> is a
collection of nodes with edges between some of those nodes. Graphs are a
generalisation of lists and trees. Each node can have multiple children and
multiple parents (we usually talk about edges into and out of a node, rather
than parents/children). Graphs can be represented by adjacency lists or
adjacency matrices. The former is basically a node object for each node in the
graph, where each node object keeps a list of its adjacent nodes. An adjacency
matrix is a matrix of booleans indicating whether there is an edge from the row
node to the column node. We'll only cover the adjacency list representation,
adjacency matrices have very different issues which are less Rust-specific.</p>
<p>There are essentially two orthogonal problems: how to handle the lifetime of the
graph and how to handle it's mutability.</p>
<p>The first problem essentially boils down to what kind of pointer to use to point
to other nodes in the graph. Since graph-like data structures are recursive (the
types are recursive, even if the data is not) we are forced to use pointers of
some kind rather than have a totally value-based structure. Since graphs can be
cyclic, and ownership in Rust cannot be cyclic, we cannot use <code>Box&lt;Node&gt;</code> as our
pointer type (as we might do for tree-like data structures or linked lists).</p>
<p>No graph is truly immutable. Because there may be cycles, the graph cannot be
created in a single statement. Thus, at the very least, the graph must be mutable
during its initialisation phase. The usual invariant in Rust is that all
pointers must either be unique or immutable. Graph edges must be mutable (at
least during initialisation) and there can be more than one edge into any node,
thus no edges are guaranteed to be unique. So we're going to have to do
something a little bit advanced to handle mutability.</p>
<p>One solution is to use mutable raw pointers (<code>*mut Node</code>). This is the most
flexible approach, but also the most dangerous. You must handle all the lifetime
management yourself without any help from the type system. You can make very
flexible and efficient data structures this way, but you must be very careful.
This approach handles both the lifetime and mutability issues in one fell swoop.
But it handles them by essentially ignoring all the benefits of Rust - you will
get no help from the compiler here (it's also not particularly ergonomic since
raw pointers don't automatically (de-)reference). Since a graph using raw
pointers is not much different from a graph in C++, I'm not going to cover that
option here.</p>
<p>The options you have for lifetime management are reference counting (shared
ownership, using <code>Rc&lt;...&gt;</code>) or arena allocation (all nodes have the same lifetime,
managed by an arena; using borrowed references <code>&amp;...</code>). The former is
more flexible (you can have references from outside the graph to individual
nodes with any lifetime), the latter is better in every other way.</p>
<p>For managing mutability, you can either use <code>RefCell</code>, i.e., make use of Rust's
facility for dynamic, interior mutability, or you can manage the mutability
yourself (in this case you have to use <code>UnsafeCell</code> to communicate the interior
mutability to the compiler). The former is safer, the latter is more efficient.
Neither is particularly ergonomic.</p>
<p>Note that if your graph might have cycles, then if you use <code>Rc</code>, further action
is required to break the cycles and not leak memory. Since Rust has no cycle
collection of <code>Rc</code> pointers, if there is a cycle in your graph, the ref counts
will never fall to zero, and the graph will never be deallocated. You can solve
this by using <code>Weak</code> pointers in your graph or by manually breaking cycles when
you know the graph should be destroyed. The former is more reliable. We don't
cover either here, in our examples we just leak memory. The approach using
borrowed references and arena allocation does not have this issue and is thus
superior in that respect.</p>
<p>To compare the different approaches I'll use a pretty simple example. We'll just
have a <code>Node</code> object to represent a node in the graph, this will hold some
string data (representative of some more complex data payload) and a <code>Vec</code> of
adjacent nodes (<code>edges</code>). We'll have an <code>init</code> function to create a simple graph
of nodes, and a <code>traverse</code> function which does a pre-order, depth-first
traversal of the graph. We'll use this to print the payload of each node in the
graph. Finally, we'll have a <code>Node::first</code> method which returns a reference to
the first adjacent node to the <code>self</code> node and a function <code>foo</code> which prints the
payload of an individual node. These functions stand in for more complex
operations involving manipulation of a node interior to the graph.</p>
<p>To try and be as informative as possible without boring you, I'll cover two
combinations of possibilities: ref counting and <code>RefCell</code>, and arena allocation
and <code>UnsafeCell</code>. I'll leave the other two combinations as an exercise.</p>
<h2 id="rcrefcellnode"><a class="header" href="#rcrefcellnode"><code>Rc&lt;RefCell&lt;Node&gt;&gt;</code></a></h2>
<p>See <a href="graphs/src/rc_graph.rs.html">full example</a>.</p>
<p>This is the safer option because there is no unsafe code. It is also the least
efficient and least ergonomic option. It is pretty flexible though, nodes of the
graph can be easily reused outside the graph since they are ref-counted. I would
recommend this approach if you need a fully mutable graph, or need your nodes to
exist independently of the graph.</p>
<p>The node structure looks like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node {
    datum: &amp;'static str,
    edges: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Creating a new node is not too bad: <code>Rc::new(RefCell::new(Node { ... }))</code>. To
add an edge during initialisation, you have to borrow the start node as mutable,
and clone the end node into the Vec of edges (this clones the pointer,
incrementing the reference count, not the actual node). E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut mut_root = root.borrow_mut();
mut_root.edges.push(b.clone());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>RefCell</code> dynamically ensures that we are not already reading or writing the
node when we write it.</p>
<p>Whenever you access a node, you have to use <code>.borrow()</code> to borrow the <code>RefCell</code>.
Our <code>first</code> method has to return a ref-counted pointer, rather than a borrowed
reference, so callers of <code>first</code> also have to borrow:</p>
<pre><pre class="playground"><code class="language-rust">fn first(&amp;self) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
    self.edges[0].clone()
}

pub fn main() {
    let g = ...;
    let f = g.first();
    foo(&amp;*f.borrow());
}
</code></pre></pre>
<h2 id="node-and-unsafecell"><a class="header" href="#node-and-unsafecell"><code>&amp;Node</code> and <code>UnsafeCell</code></a></h2>
<p>See <a href="graphs/src/ref_graph.rs.html">full example</a>.</p>
<p>In this approach we use borrowed references as edges. This is nice and ergonomic
and lets us use our nodes with 'regular' Rust libraries which primarily operate
with borrowed references (note that one nice thing about ref counted objects in
Rust is that they play nicely with the lifetime system. We can create a borrowed
reference into the <code>Rc</code> to directly (and safely) reference the data. In the
previous example, the <code>RefCell</code> prevents us doing this, but an <code>Rc</code>/<code>UnsafeCell</code>
approach should allow it).</p>
<p>Destruction is correctly handled too - the only constraint is that all the nodes
must be destroyed at the same time. Destruction and allocation of nodes is
handled using an arena.</p>
<p>On the other hand, we do need to use quite a few explicit lifetimes.
Unfortunately we don't benefit from lifetime elision here. At the end of the
section I'll discuss some future directions for the language which could make
things better.</p>
<p>During construction we will mutate our nodes which might be multiply referenced.
This is not possible in safe Rust code, so we must initialise inside an <code>unsafe</code>
block. Since our nodes are mutable and multiply referenced, we must use an
<code>UnsafeCell</code> to communicate to the Rust compiler that it cannot rely on its
usual invariants.</p>
<p>When is this approach feasible? The graph must only be mutated during
initialisation. In addition, we require that all nodes in the graph have the
same lifetime (we could relax these constraints somewhat to allow adding nodes
later as long as they can all be destroyed at the same time). Similarly, we
could rely on more complicated invariants for when the nodes can be mutated, but
it pays to keep things simple, since the programmer is responsible for safety
in those respects.</p>
<p>Arena allocation is a memory management technique where a set of objects have
the same lifetime and can be deallocated at the same time. An arena is an object
responsible for allocating and deallocating the memory. Since large chunks of
memory are allocated and deallocated at once (rather than allocating individual
objects), arena allocation is very efficient. Usually, all the objects are
allocated from a contiguous chunk of memory, that improves cache coherency when
you are traversing the graph.</p>
<p>In Rust, arena allocation is supported by the <a href="https://doc.rust-lang.org/1.1.0/arena/index.html">libarena</a>
crate and is used throughout the compiler. There are two kinds of arenas - typed
and untyped. The former is more efficient and easier to use, but can only
allocate objects of a single type. The latter is more flexible and can allocate
any object. Arena allocated objects all have the same lifetime, which is a
parameter of the arena object. The type system ensures references to arena
allocated objects cannot live longer than the arena itself.</p>
<p>Our node struct must now include the lifetime of the graph, <code>'a</code>. We wrap our
<code>Vec</code> of adjacent nodes in an <code>UnsafeCell</code> to indicate that we will mutate it
even when it should be immutable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Node&lt;'a&gt; {
    datum: &amp;'static str,
    edges: UnsafeCell&lt;Vec&lt;&amp;'a Node&lt;'a&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Our new function must also use this lifetime and must take as an argument the
arena which will do the allocation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new&lt;'a&gt;(datum: &amp;'static str, arena: &amp;'a TypedArena&lt;Node&lt;'a&gt;&gt;) -&gt; &amp;'a Node&lt;'a&gt; {
    arena.alloc(Node {
        datum: datum,
        edges: UnsafeCell::new(Vec::new()),
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>We use the arena to allocate the node. The lifetime of the graph is derived from
the lifetime of the reference to the arena, so the arena must be passed in from
the scope which covers the graph's lifetime. For our examples, that means we
pass it into the <code>init</code> method. (One could imagine an extension to the type
system which allows creating values at scopes outside their lexical scope, but
there are no plans to add such a thing any time soon). When the arena goes out
of scope, the whole graph is destroyed (Rust's type system ensures that we can't
keep references to the graph beyond that point).</p>
<p>Adding an edge is a bit different looking:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(*root.edges.get()).push(b);
<span class="boring">}
</span></code></pre></pre>
<p>We're essentially doing the obvious <code>root.edges.push(b)</code> to push a node (<code>b</code>) on
to the list of edges. However, since <code>edges</code> is wrapped in an <code>UnsafeCell</code>, we
have to call <code>get()</code> on it. That gives us a mutable raw pointer to edges (<code>*mut Vec&lt;&amp;Node&gt;</code>), which allows us to mutate <code>edges</code>. However, it also requires us to
manually dereference the pointer (raw pointers do not auto-deref), thus the
<code>(*...)</code> construction. Finally, dereferencing a raw pointer is unsafe, so the
whole lot has to be wrapped up in an unsafe block.</p>
<p>The interesting part of <code>traverse</code> is:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for n in &amp;(*self.edges.get()) {
    n.traverse(f, seen);
}
<span class="boring">}
</span></code></pre></pre>
<p>We follow the previous pattern for getting at the edges list, which requires an
unsafe block. In this case we know it is in fact safe because we must be post-
initialisation and thus there will be no mutation.</p>
<p>Again, the <code>first</code> method follows the same pattern for getting at the <code>edges</code>
list. And again must be in an unsafe block. However, in contrast to the graph
using <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, we can return a straightforward borrowed reference to
the node. That is very convenient. We can reason that the unsafe block is safe
because we do no mutation and we are post-initialisation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first(&amp;'a self) -&gt; &amp;'a Node&lt;'a&gt; {
    unsafe {
        (*self.edges.get())[0]
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="future-language-improvements-for-this-approach"><a class="header" href="#future-language-improvements-for-this-approach">Future language improvements for this approach</a></h3>
<p>I believe that arena allocation and using borrowed references are an important
pattern in Rust. We should do more in the language to make these patterns safer
and easier to use. I hope use of arenas becomes more ergonomic with the ongoing
work on <a href="https://github.com/rust-lang/rfcs/pull/244">allocators</a>. There are
three other improvements I see:</p>
<h4 id="safe-initialisation"><a class="header" href="#safe-initialisation">Safe initialisation</a></h4>
<p>There has been lots of research in the OO world on mechanisms for ensuring
mutability only during initialisation. How exactly this would work in Rust is an
open research question, but it seems that we need to represent a pointer which
is mutable and not unique, but restricted in scope. Outside that scope any
existing pointers would become normal borrowed references, i.e., immutable <em>or</em>
unique.</p>
<p>The advantage of such a scheme is that we have a way to represent the common
pattern of mutable during initialisation, then immutable. It also relies on the
invariant that, while individual objects are multiply owned, the aggregate (in
this case a graph) is uniquely owned. We should then be able to adopt the
reference and <code>UnsafeCell</code> approach, without the <code>UnsafeCell</code>s and the unsafe
blocks, making that approach more ergonomic and more safer.</p>
<p>Alex Summers and Julian Viereck at ETH Zurich are investigating this
further.</p>
<h4 id="generic-modules"><a class="header" href="#generic-modules">Generic modules</a></h4>
<p>The 'lifetime of the graph' is constant for any particular graph. Repeating the
lifetime is just boilerplate. One way to make this more ergonomic would be to
allow the graph module to be parameterised by the lifetime, so it would not need
to be added to every struct, impl, and function. The lifetime of the graph would
still need to be specified from outside the module, but hopefully inference
would take care of most uses (as it does today for function calls).</p>
<p>See <a href="graphs/src/ref_graph_generic_mod.rs.html">ref_graph_generic_mod.rs</a> for how that might look.
(We should also be able to use safe initialisation (proposed above) to remove
the unsafe code).</p>
<p>See also this <a href="https://github.com/rust-lang/rfcs/issues/424">RFC issue</a>.</p>
<p>This feature would vastly reduce the syntactic overhead of the reference and
<code>UnsafeCell</code> approach.</p>
<h4 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime elision</a></h4>
<p>We currently allow the programmer to elide some lifetimes in function signatures
to improve ergonomics. One reason the <code>&amp;Node</code> approach to graphs is a bit ugly
is because it doesn't benefit from any of the lifetime elision rules.</p>
<p>A common pattern in Rust is data structures with a common lifetime. References
into such data structures give rise to types like <code>&amp;'a Foo&lt;'a&gt;</code>, for example
<code>&amp;'a Node&lt;'a&gt;</code> in the graph example. It would be nice to have an elision
rule that helps in this case. I'm not really sure how it should work though.</p>
<p>Looking at the example with generic modules, it doesn't look like we need to
extend the lifetime elision rules very much (I'm not actually sure if
<code>Node::new</code> would work without the given lifetimes, but it seems like a fairly
trivial extension to make it work if it doesn't). We might want to add some new
rule to allow elision of module-generic lifetimes if they are the only ones in
scope (other than <code>'static</code>), but I'm not sure how that would work with multiple
in- scope lifetimes (see the <code>foo</code> and <code>init</code> functions, for example).</p>
<p>If we don't add generic modules, we might still be able to add an elision rule
specifically to target <code>&amp;'a Node&lt;'a&gt;</code>, not sure how though.</p>
<div style="break-before: page; page-break-before: always;"></div><pre><pre class="playground"><code class="language-rust">#![feature(rustc_private)]

extern crate arena;

mod rc_graph;
mod ref_graph;

fn main() {
    println!(&quot;\nRc&lt;RefCell&lt;Node&gt;&gt;:&quot;);
    rc_graph::main();
    println!(&quot;\n&amp;Node and UnsafeCell:&quot;);
    ref_graph::main();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;
use std::collections::HashSet;

struct Node {
    datum: &amp;'static str,
    edges: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    fn new(datum: &amp;'static str) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
        Rc::new(RefCell::new(Node {
            datum: datum,
            edges: Vec::new(),
        }))
    }

    fn traverse&lt;F&gt;(&amp;self, f: &amp;F, seen: &amp;mut HashSet&lt;&amp;'static str&gt;)
        where F: Fn(&amp;'static str)
    {
        if seen.contains(&amp;self.datum) {
            return;
        }
        f(self.datum);
        seen.insert(self.datum);
        for n in &amp;self.edges {
            n.borrow().traverse(f, seen);
        }
    }

    fn first(&amp;self) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
        self.edges[0].clone()
    }
}

fn foo(node: &amp;Node) {
    println!(&quot;foo: {}&quot;, node.datum);
}

fn init() -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
    let root = Node::new(&quot;A&quot;);

    let b = Node::new(&quot;B&quot;);
    let c = Node::new(&quot;C&quot;);
    let d = Node::new(&quot;D&quot;);
    let e = Node::new(&quot;E&quot;);
    let f = Node::new(&quot;F&quot;);

    {
        let mut mut_root = root.borrow_mut();
        mut_root.edges.push(b.clone());
        mut_root.edges.push(c.clone());
        mut_root.edges.push(d.clone());

        let mut mut_c = c.borrow_mut();
        mut_c.edges.push(e.clone());
        mut_c.edges.push(f.clone());
        mut_c.edges.push(root.clone());
    }

    root
}

pub fn main() {
    let g = init();
    let g = g.borrow();
    g.traverse(&amp;|d| println!(&quot;{}&quot;, d), &amp;mut HashSet::new());
    let f = g.first();
    foo(&amp;*f.borrow());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><pre class="playground"><code class="language-rust">// Note that this one is hypothetical future Rust and will not compile today.

use std::cell::UnsafeCell;
use std::collections::HashSet;
use arena::TypedArena;

// Module is parameterised with the lifetime of the graph.
mod graph&lt;'a&gt; {
    struct Node {
        datum: &amp;'static str,
        // The module-level lifetime is used for the lifetime of each Node.
        edges: UnsafeCell&lt;Vec&lt;&amp;'a Node&gt;&gt;,
    }

    impl Node {
        fn new(datum: &amp;'static str, arena: &amp;'a TypedArena&lt;Node&gt;) -&gt; &amp;'a Node {
            arena.alloc(Node {
                datum: datum,
                edges: UnsafeCell::new(Vec::new()),
            })
        }

        fn traverse&lt;F&gt;(&amp;self, f: &amp;F, seen: &amp;mut HashSet&lt;&amp;'static str&gt;)
            where F: Fn(&amp;'static str)
        {
            if seen.contains(&amp;self.datum) {
                return;
            }
            f(self.datum);
            seen.insert(self.datum);
            for n in &amp;self.edges {
                unsafe {
                    for n in &amp;(*self.edges.get()) {
                        n.traverse(f, seen);
                    }
                }
            }
        }

        fn first(&amp;self) -&gt; &amp;Node {
            unsafe {
                (*self.edges.get())[0]
            }
        }
    }

    // It would be nice if we could rely on lifetime elision and remove the `'a`
    // on the `foo` and `init` functions.
    fn foo(node: &amp;'a Node) {
        println!(&quot;foo: {}&quot;, node.datum);
    }

    fn init(arena: &amp;'a TypedArena&lt;Node&gt;) -&gt; &amp;'a Node {
        let root = Node::new(&quot;A&quot;, arena);

        let b = Node::new(&quot;B&quot;, arena);
        let c = Node::new(&quot;C&quot;, arena);
        let d = Node::new(&quot;D&quot;, arena);
        let e = Node::new(&quot;E&quot;, arena);
        let f = Node::new(&quot;F&quot;, arena);

        unsafe {
            (*root.edges.get()).push(b);
            (*root.edges.get()).push(c);
            (*root.edges.get()).push(d);

            (*c.edges.get()).push(e);
            (*c.edges.get()).push(f);
            (*c.edges.get()).push(root);
        }

        root
    }
}

pub fn main() {
    let arena = TypedArena::new();
    // The lifetime of the module is inferred here from the lifetime of the
    // reference to the arena, i.e., the scope of the main function.
    let g = graph::init(&amp;arena);
    g.traverse(&amp;|d| println!(&quot;{}&quot;, d), &amp;mut HashSet::new());
    foo(g.first());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><pre class="playground"><code class="language-rust">use std::cell::UnsafeCell;
use std::collections::HashSet;
use arena::TypedArena;

struct Node&lt;'a&gt; {
    datum: &amp;'static str,
    edges: UnsafeCell&lt;Vec&lt;&amp;'a Node&lt;'a&gt;&gt;&gt;,
}

impl&lt;'a&gt; Node&lt;'a&gt; {
    fn new&lt;'b&gt;(datum: &amp;'static str, arena: &amp;'b TypedArena&lt;Node&lt;'b&gt;&gt;) -&gt; &amp;'b Node&lt;'b&gt; {
        arena.alloc(Node {
            datum: datum,
            edges: UnsafeCell::new(Vec::new()),
        })
    }

    fn traverse&lt;F&gt;(&amp;self, f: &amp;F, seen: &amp;mut HashSet&lt;&amp;'static str&gt;)
        where F: Fn(&amp;'static str)
    {
        if seen.contains(&amp;self.datum) {
            return;
        }
        f(self.datum);
        seen.insert(self.datum);
        unsafe {
            for n in &amp;(*self.edges.get()) {
                n.traverse(f, seen);
            }
        }
    }

    fn first(&amp;'a self) -&gt; &amp;'a Node&lt;'a&gt; {
        unsafe {
            (*self.edges.get())[0]
        }
    }
}

fn foo&lt;'a&gt;(node: &amp;'a Node&lt;'a&gt;) {
    println!(&quot;foo: {}&quot;, node.datum);
}

fn init&lt;'a&gt;(arena: &amp;'a TypedArena&lt;Node&lt;'a&gt;&gt;) -&gt;&amp;'a Node&lt;'a&gt; {
    let root = Node::new(&quot;A&quot;, arena);

    let b = Node::new(&quot;B&quot;, arena);
    let c = Node::new(&quot;C&quot;, arena);
    let d = Node::new(&quot;D&quot;, arena);
    let e = Node::new(&quot;E&quot;, arena);
    let f = Node::new(&quot;F&quot;, arena);

    unsafe {
        (*root.edges.get()).push(b);
        (*root.edges.get()).push(c);
        (*root.edges.get()).push(d);

        (*c.edges.get()).push(e);
        (*c.edges.get()).push(f);
        (*c.edges.get()).push(root);
    }

    root
}

pub fn main() {
    let arena = TypedArena::new();
    let g = init(&amp;arena);
    g.traverse(&amp;|d| println!(&quot;{}&quot;, d), &amp;mut HashSet::new());
    foo(g.first());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures-and-first-class-functions"><a class="header" href="#closures-and-first-class-functions">Closures and first-class functions</a></h1>
<p>Closures and first-class and higher order functions are a core part of Rust. In
C and C++ there are function pointers (and those weird member/method pointer
things in C++ that I never got the hang of). However, they are used relatively
rarely and are not very ergonomic. C++11 introduced lambdas, and these are
pretty close to Rust closures, in particular they have a very similar
implementation strategy.</p>
<p>To start with, I want to establish some intuition for these things. Then, we'll
dive in to the details.</p>
<p>Lets say we have a function <code>foo</code>: <code>pub fn foo() -&gt; u32 { 42 }</code>. Now let's
imagine another function <code>bar</code> which takes a function as an argument (I'll leave
<code>bar</code>'s signature for later): <code>fn bar(f: ...) { ... }</code>. We can pass <code>foo</code> to
<code>bar</code> kind of like we would pass a function pointer in C: <code>bar(foo)</code>. In the
body of <code>bar</code> we can call <code>f</code> as if it were a function: <code>let x = f();</code>.</p>
<p>We say that Rust has first-class functions because we can pass them around and
use them like we can with other values. We say <code>bar</code> is a higher-order function
because it takes a function as an argument, i.e., it is a function that operates
on functions.</p>
<p>Closures in Rust are anonymous functions with a nice syntax. A closure <code>|x| x + 2</code> takes an argument and returns it with <code>2</code> added. Note that we don't have to
give types for the arguments to a closure (they can usually be inferred). We
also don't need to specify a return type. If we want the closure body to be more
than just one expression, we can use braces: <code>|x: i32| { let y = x + 2; y }</code>. We
can pass closures just like functions: <code>bar(|| 42)</code>.</p>
<p>The big difference between closures and other functions is that closures capture
their environment. This means that we can refer to variables outside the closure
from the closure. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
bar(|| x);
<span class="boring">}
</span></code></pre></pre>
<p>Note how <code>x</code> is in scope in the closure.</p>
<p>We've seen closures before, used with iterators, and this is a common use case
for them. E.g., to add a value to each element of a vector:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn baz(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let z = 3;
    v.iter().map(|x| x + z).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>x</code> is an argument to the closure, each member of <code>v</code> will be passed as an
<code>x</code>. <code>z</code> is declared outside of the closure, but because it's a closure, <code>z</code> can
be referred to. We could also pass a function to map:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_two(x: i32) -&gt; i32 {
    x + 2
}

fn baz(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.iter().map(add_two).collect()
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that Rust also allows declaring functions inside of functions. These are
<em>not</em> closures - they can't access their environment. They are merely a
convenience for scoping.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn qux(x: i32) {
    fn quxx() -&gt; i32 {
        x // ERROR x is not in scope.
    }

    let a = quxx();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="function-types"><a class="header" href="#function-types">Function types</a></h2>
<p>Lets introduce a new example function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_42(x: i32) -&gt; i64 {
    x as i64 + 42
}
<span class="boring">}
</span></code></pre></pre>
<p>As we saw before, we can store a function in a variable: <code>let a = add_42;</code>. The
most precise type of <code>a</code> cannot be written in Rust. You'll sometimes see the
compiler render it as <code>fn(i32) -&gt; i64 {add_42}</code> in error messages. Each function
has its own unique and anonymous type. <code>fn add_41(x: i32) -&gt; i64</code> has a different
type, even though it has the same signature.</p>
<p>We can write less precise types, for example, <code>let a: fn(i32) -&gt; i64 = add_42;</code>.
All function types with the same signature can be coerced to a <code>fn</code> type
(which can be written by the programmer).</p>
<p><code>a</code> is represented by the compiler as a function pointer, however, if the
compiler knows the precise type, it doesn't actually use that function pointer.
A call like a() is statically dispatched based on the type of a. If the
compiler doesn't know the precise type (e.g., it only knows the fn type), then
the call is dispatched using the function pointer in the value.</p>
<p>There are also <code>Fn</code> types (note the capital 'F'). These <code>Fn</code> types are bounds,
just like traits (in fact they <em>are</em> traits, as we'll see later). <code>Fn(i32) -&gt; i64</code>
is a bound on the types of all function-like objects with that signature. When
we take a reference to a function pointer, we're actually creating a trait
object which is represented by a fat pointer (see DSTs).</p>
<p>To pass a function to another function, or to store the function in a field, we
must write a type. We have several choices, we can either use either a <code>fn</code> type
or a <code>Fn</code> type. The latter is better because it includes closures (and
potentially other function-like things), whereas <code>fn</code> types don't. The <code>Fn</code>
types are dynamically sized which means we cannot use them as value types. We
must either pass function objects or use generics. Let's look at the generic
approach first. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;F&gt;(f: F) -&gt; i64
    where F: Fn(i32) -&gt; i64
{
    f(0)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>bar</code> takes any function with the signature <code>Fn(i32) -&gt; i64</code>, i.e., we can
instantiate the <code>F</code> type parameter with any function-like type. We could call
<code>bar(add_42)</code> to pass <code>add_42</code> to <code>bar</code> which would instantiate <code>F</code> with
<code>add_42</code>'s anonymous type. We could also call <code>bar(add_41)</code> and that would work
too.</p>
<p>You can also pass closures to <code>bar</code>, e.g., <code>bar(|x| x as i64)</code>. This works
because closure types are also bounded by the <code>Fn</code> bound matching their
signature (like functions, each closure has it's own anonymous type).</p>
<p>Finally, you can pass references to functions or closures too: <code>bar(&amp;add_42)</code> or
<code>bar(&amp;|x| x as i64)</code>.</p>
<p>One could also write <code>bar</code> as <code>fn bar(f: &amp;Fn(i32) -&gt; i64) ...</code>. These two
approaches (generics vs a function/trait object) have quite different semantics.
In the generics case, <code>bar</code> will be monomorphised so when code is generated, the
compiler know the exact type of <code>f</code>, that means it can be statically dispatched.
If using a function object, the function is not monomorphised. The exact type of
<code>f</code> is not known, and so the compiler must generate a virtual dispatch. The
latter is slower, but the former will produce more code (one monomorphised
function per type parameter instance).</p>
<p>There are actually more function traits than just <code>Fn</code>; there are <code>FnMut</code> and
<code>FnOnce</code> too. These are used in the same way as <code>Fn</code>, e.g., <code>FnOnce(i32) -&gt; i64</code>. A <code>FnMut</code> represents an object which can be called and can be mutated
during that call. This doesn't apply to normal functions, but for closures it
means the closure can mutate its environment. <code>FnOnce</code> is a function which can
only be called (at most) once. Again, this is only relevant for closures.</p>
<p><code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> are in a sub-trait hierarchy. <code>Fn</code>s are <code>FnMut</code>s
(because one can call a <code>Fn</code> function with permission to mutate and no harm is
done, but the opposite is not true). <code>Fn</code>s and <code>FnMut</code>s are <code>FnOnce</code>s (because
there is no harm done if a regular function is only called once, but not the
opposite).</p>
<p>So, to make a higher-order function as flexible as possible, you should use the
<code>FnOnce</code> bound, rather than the <code>Fn</code> bound (or use the <code>FnMut</code> bound if you must
call the function more than once).</p>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>You can use methods in the same way as functions - take pointers to them store
them in variables, etc. You can't use the dot syntax, you must explicitly name
the method using the fully explicit form of naming (sometimes called UFCS for
universal function call syntax). The <code>self</code> parameter is the first argument to
the method. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">struct Foo;

impl Foo {
    fn bar(&amp;self) {}
}

trait T {
    fn baz(&amp;self);
}

impl T for Foo {
    fn baz(&amp;self) {}
}

fn main() {
    // Inherent method.
    let x = Foo::bar;
    x(&amp;Foo);
    
    // Trait method, note the fully explicit naming form.
    let y = &lt;Foo as T&gt;::baz;
    y(&amp;Foo);
}
</code></pre></pre>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic functions</a></h3>
<p>You can't take a pointer to a generic function and there is no way to express a
generic function type. However, you can take a reference to a function if all
its type parameters are instantiated. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;T&gt;(x: &amp;T) {}

fn main() {
    let x = &amp;foo::&lt;i32&gt;;
    x(&amp;42);
}
</code></pre></pre>
<p>There is no way to define a generic closure. If you need a closure to work over
many types you can use trait objects, macros (for generating closures), or pass
a closure which returns closures (each returned closure can operate on a
different type).</p>
<h3 id="lifetime-generic-functions-and-higher-ranked-types"><a class="header" href="#lifetime-generic-functions-and-higher-ranked-types">Lifetime-generic functions and higher-ranked types</a></h3>
<p>It <em>is</em> possible to have function types and closures which are generic over
lifetimes. </p>
<p>Imagine we have a closure which takes a borrowed reference. The closure can work
the same way no matter what lifetime the reference has (and indeed in the
compiled code, the lifetime will have been erased). But, what does the type look
like?</p>
<p>For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F&gt;(x: &amp;Bar, f: F) -&gt; &amp;Baz
    where F: Fn(&amp;Bar) -&gt; &amp;Baz
{
    f(x)
}
<span class="boring">}
</span></code></pre></pre>
<p>what are the lifetimes of the references here? In this simple example, we can
use a single lifetime (no need for a generic closure):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'b, F&gt;(x: &amp;'b Bar, f: F) -&gt; &amp;'b Baz
    where F: Fn(&amp;'b Bar) -&gt; &amp;'b Baz
{
    f(x)
}
<span class="boring">}
</span></code></pre></pre>
<p>But what if we want <code>f</code> to work on inputs with different lifetimes? Then we need
a generic function type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'b, 'c, F&gt;(x: &amp;'b Bar, y: &amp;'c Bar, f: F) -&gt; (&amp;'b Baz, &amp;'c Baz)
    where F: for&lt;'a&gt; Fn(&amp;'a Bar) -&gt; &amp;'a Baz
{
    (f(x), f(y))
}
<span class="boring">}
</span></code></pre></pre>
<p>The novelty here is the <code>for&lt;'a&gt;</code> syntax, this is used to denote a function type
which is generic over a lifetime. It is read &quot;for all 'a, ...&quot;. In theoretical
terms, the function type is universally quantified.</p>
<p>Note that we cannot hoist up <code>'a</code> to <code>foo</code> in the above example. Counter-example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, 'b, 'c, F&gt;(x: &amp;'b Bar, y: &amp;'c Bar, f: F) -&gt; (&amp;'b Baz, &amp;'c Baz)
    where F: Fn(&amp;'a Bar) -&gt; &amp;'a Baz
{
    (f(x), f(y))
}
<span class="boring">}
</span></code></pre></pre>
<p>will not compile because when the compiler infers lifetimes for a call to <code>foo</code>,
it must pick a single lifetime for <code>'a</code>, which it can't do if <code>'b</code> and <code>'c</code> are
different.</p>
<p>A function type which is generic in this way is called a higher-ranked type.
Lifetime variables at the outer level have rank one. Because <code>'a</code> in the above
example cannot be moved to the outer level, it's rank is higher than one.</p>
<p>Calling functions with higher-ranked function type arguments is easy - the
compiler will infer the lifetime parameters. E.g., <code>foo(&amp;Bar { ... }, &amp;Bar {...}, |b| &amp;b.field)</code>.</p>
<p>In fact, most of the time you don't even need to worry about such things. The
compiler will allow you to elide the quantified lifetimes in the same way that
you are allowed to elide many lifetimes on function arguments. For example, the
example above can just be written as</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'b, 'c, F&gt;(x: &amp;'b Bar, y: &amp;'c Bar, f: F) -&gt; (&amp;'b Baz, &amp;'c Baz)
    where F: Fn(&amp;Bar) -&gt; &amp;Baz
{
    (f(x), f(y))
}
<span class="boring">}
</span></code></pre></pre>
<p>(and you only need <code>'b</code> and <code>'c</code> because it is a contrived example).</p>
<p>Where Rust sees a function type with a borrowed references, it will apply the
usual elision rules, and quantify the elided variables at the scope of the
function type (i.e., with higher rank).</p>
<p>You might be wondering why bother with all this complexity for what looks like a
fairly niche use case. The real motivation is functions which take a function
to operate on some data provided by the outer function. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F&gt;(f: F)
    where F: Fn(&amp;i32) // Fully explicit type: for&lt;'a&gt; Fn(&amp;'a i32)
{
    let data = 42;
    f(&amp;data)
}
<span class="boring">}
</span></code></pre></pre>
<p>In these cases, we <em>need</em> higher-ranked types. If we added a lifetime parameter
to <code>foo</code> instead, we could never infer a correct lifetime. To see why, let's
look at how it might work, consider <code>fn foo&lt;'a, F: Fn(&amp;'a i32')&gt; ...</code>. Rust
requires that any lifetime parameter must outlive the item it is declared on (if
this were not the case, an argument with that lifetime could be used inside that
function, where it is not guaranteed to be live). In the body of <code>foo</code> we use
<code>f(&amp;data)</code>, the lifetime Rust will infer for that reference will last (at most)
from where <code>data</code> is declared to where it goes out of scope. Since <code>'a</code> must
outlive <code>foo</code>, but that inferred lifetime does not, we cannot call <code>f</code> in this
way.</p>
<p>However, with higher-ranked lifetimes <code>f</code> can accept any lifetime and so the
anonymous one from <code>&amp;data</code> is fine and the function type checks.</p>
<h3 id="enum-constructors"><a class="header" href="#enum-constructors">Enum constructors</a></h3>
<p>This is something of a digression, but it is sometimes a useful trick. All
variants of an enum define a function from the fields of the variant to the enum
type. For example,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz(i32),
}
<span class="boring">}
</span></code></pre></pre>
<p>defines two functions, <code>Foo::Bar: Fn() -&gt; Foo</code> and <code>Foo::Baz: Fn(i32) -&gt; Foo</code>.
We don't normally use the variants in this way, we treat them as data types
rather than functions. But sometimes it is useful, for example if we have a list
of <code>i32</code>s we can create a list of <code>Foo</code>s with</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>list_of_i32.iter().map(Foo::Baz).collect()
<span class="boring">}
</span></code></pre></pre>
<h2 id="closure-flavours"><a class="header" href="#closure-flavours">Closure flavours</a></h2>
<p>A closure has two forms of input: the arguments which are passed to it explicitly
and the variables it <em>captures</em> from its environment. Usually, everything about
both kinds of input is inferred, but you can have more control if you want it.</p>
<p>For the arguments, you can declare types instead of letting Rust infer them. You
can also declare a return type. Rather than writing <code>|x| { ... }</code> you can write
<code>|x: i32| -&gt; String { ... }</code>. Whether an argument is owned or borrowed is 
determined by the types (either declared or inferred).</p>
<p>For the captured variables, the type is mostly known from the environment, but
Rust does a little extra magic. Should a variable be captured by reference or
value? Rust infers this from the body of the closure. If possible, Rust captures
by reference. E.g.,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: Bar) {
    let f = || { ... x ... };
}
<span class="boring">}
</span></code></pre></pre>
<p>All being well, in the body of <code>f</code>, <code>x</code> has the type <code>&amp;Bar</code> with a lifetime
bounded by the scope of <code>foo</code>. However, if <code>x</code> is mutated, then Rust will infer
that the capture is by mutable reference, i.e., <code>x</code> has type <code>&amp;mut Bar</code>. If <code>x</code>
is moved in <code>f</code> (e.g., is stored into a variable or field with value type), then
Rust infers that the variable must be captured by value, i.e., it has the type
<code>Bar</code>.</p>
<p>This can be overridden by the programmer (sometimes necessary if the closure
will be stored in a field or returned from a function). By using the <code>move</code>
keyword in front of a closure. Then, all of the captured variables are captured
by value. E.g., in <code>let f = move || { ... x ... };</code>, <code>x</code> would always have type
<code>Bar</code>.</p>
<p>We talked earlier about the different function kinds: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>.
We can now explain why we need them. For closures, the mutable-ness and once-ness
refer to the captured variables. If a capture mutates any of the variables it
captures then it will have a <code>FnMut</code> type (note that this is completely inferred
by the compiler, no annotation is necessary). If a variable is moved into a
closure, i.e., it is captured by value (either because of an explicit <code>move</code> or
due to inference), then the closure will have a <code>FnOnce</code> type. It would be unsafe
to call such a closure multiple times because the captured variable would be
moved more than once.</p>
<p>Rust will do its best to infer the most flexible type for the closure if it can.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A closure is implemented as an anonymous struct. That struct has a field for
each variable captured by the closure. It is lifetime-parametric with a single
lifetime parameter which is a bound on the lifetime of captured variables. The
anonymous struct implements a <code>call</code> method which is called to execute the
closure.</p>
<p>For example, consider</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Foo { ... };
    let f = |y| x.get_number() + y;
    let z = f(42);
}
</code></pre></pre>
<p>the compiler treats this as</p>
<pre><pre class="playground"><code class="language-rust">struct Closure14&lt;'env&gt; {
    x: &amp;'env Foo,
}

// Not actually implemented like this, see below.
impl&lt;'env&gt; Closure14&lt;'env&gt; {
    fn call(&amp;self, y: i32) -&gt; i32 {
        self.x.get_number() + y
    }
}

fn main() {
    let x = Foo { ... };
    let f = Closure14 { x: x }
    let z = f.call(42);
}
</code></pre></pre>
<p>As we mentioned above, there are three different function traits - <code>Fn</code>,
<code>FnMut</code>, and <code>FnOnce</code>. In reality the <code>call</code> method is required by these traits
rather than being in an inherent impl. <code>Fn</code> has a method <code>call</code> which takes
<code>self</code> by reference, <code>FnMut</code> has <code>call_mut</code> taking <code>self</code> by mutable reference,
and <code>FnOnce</code> has <code>call_once</code> which takes <code>self</code> by values.</p>
<p>When we've seen function types above, they look like <code>Fn(i32) -&gt; i32</code> which
doesn't look much like a trait type. There is a little bit of magic here. Rust allows
this round bracket sugar only for function types. To desugar to a regular type
(an 'angle bracket type'), the argument types are treated as a tuple type and
passed as a type parameter and the return type as an associated type called
<code>Output</code>. So, <code>Fn(i32) -&gt; i32</code> is desugared to <code>Fn&lt;(i32,), Output=i32&gt;</code> and the
<code>Fn</code> trait definition looks like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    fn call(&amp;self, args: Args) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>The implementation for <code>Closure14</code> above would therefore look more like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'env&gt; FnOnce&lt;(i32,)&gt; for Closure14&lt;'env&gt; {
    type Output = i32;
    fn call_once(self, args: (i32,)) -&gt; i32 {
        ...
    }
}
impl&lt;'env&gt; FnMut&lt;(i32,)&gt; for Closure14&lt;'env&gt; {
    fn call_mut(&amp;mut self, args: (i32,)) -&gt; i32 {
        ...
    }
}
impl&lt;'env&gt; Fn&lt;(i32,)&gt; for Closure14&lt;'env&gt; {
    fn call(&amp;self, args: (i32,)) -&gt; i32 {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can find the function traits in
<a href="https://dxr.mozilla.org/rust/source/src/libcore/ops.rs">core::ops</a></p>
<p>We talked above about how using generics gives static dispatch and using trait
objects gives virtual dispatch. We can now see in a bit more detail why.</p>
<p>When we call <code>call</code>, it is a statically dispatched method call, there is no
virtual dispatch. If we pass it to a monomorphised function, we still know the
type statically, and we still get a static dispatch.</p>
<p>We can make the closure into a trait object, e.g., <code>&amp;f</code> or <code>Box::new(f)</code> with
types <code>&amp;Fn(i32)-&gt;i32</code> or <code>Box&lt;Fn(i32)-&gt;i32&gt;</code>. These are pointer types, and
because they are pointer-to-trait types, the pointers are fat pointers. That
means they consist of the pointer to the data itself and a pointer to a vtable.
The vtable is used to lookup the address of <code>call</code> (or <code>call_mut</code> or whatever).</p>
<p>You'll sometimes hear these two representations of closures called boxed and
unboxed closures. An unboxed closure is the by-value version with static
dispatch. A boxed version is the trait object version with dynamic dispatch. In
the olden days, Rust only had boxed closures (and the system was quite a bit
different).</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0114-closures.md">RFC 114 - Closures</a></li>
<li><a href="http://huonw.github.io/blog/2015/05/finding-closure-in-rust/">Finding Closure in Rust blog post</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0387-higher-ranked-trait-bounds.md">RFC 387 - Higher ranked trait bounds</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/">Purging proc blog post</a></li>
</ul>
<p>FIXME: relate to closures in C++ 11</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
